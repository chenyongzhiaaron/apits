# 任务消息模型

## 1. 说明

在刚才的基本模型中，一个生产者，一个消费者，生产的消息直接被消费者消费，比较简单。接下来要学习的`Work queues`，也被称为（Task queues），任务模型

```
这种方式最大的特点：可以被多个消费者消费
```

## 2. 使用场景

当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型。

```
让多个消费者绑定到一个队列，共同消费队列中的消息
特点：队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的
```

图示如下：

![1527078437166](assets/1527078437166.png)

说明：

- P：生产者：任务的发布者
- C1：消费者1，领取任务并且完成任务，假设完成速度较慢
- C2：消费者2：领取任务并且完成任务，假设完成速度快

## 3. demo

### 3.1 生产者（发送方）

代码与之前的很类似，不过这里我们是循环发送50条消息

```python
import pika

# 无论是生产者还是消费者，都需要和 RabbitMQ Broker 建立连接
# 发送给某个用户，需要写用户IP，此处发给本机，使用localhost
# Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))

# 创建一个通道，Channel是在connection内部建立的逻辑连接
channel = connection.channel()

# 声明消息队列，消息将在这个队列中传递。如果消息发送给不存在的队列，rabbitmq将会自动清除这些信息
channel.queue_declare(queue='hello')

# 发送消息到声明的hello队列，其中exchange表示交换器，能够精准指定消息发送到那个队列，routing_key设置为队列的名称，body就是发送的内容。
# 循环发送50次
for i in range(50):
    channel.basic_publish(exchange='', routing_key='hello', body='task %d' % (i + 1))

print("send msg----ok")

# 关闭连接
connection.close()
```

### 3.2 消费者1（慢）

```python
import time

import pika

# 建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
# 建立通道
channel = connection.channel()
# 声明消息队列
channel.queue_declare(queue='hello')

# 定义变量用来记录是第几次接收到数据
receive_num = 1


# 定义回调函数，处理接收到的信息
def callback(ch, method, properties, body):
    global receive_num
    print("第{}次接收数据：{}".format(receive_num, body))
    receive_num += 1
    time.sleep(1)


# rabbitmq使用callback来接收信息
channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)

print('Waiting for messages. To exit press CTRL+C')

# 开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。
channel.start_consuming()
```

![image-20191127225328330](assets/image-20191127225328330.png)

### 消费者2（快）

```python
import time

import pika

# 建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
# 建立通道
channel = connection.channel()
# 声明消息队列
channel.queue_declare(queue='hello')

# 定义变量用来记录是第几次接收到数据
receive_num = 1


# 定义回调函数，处理接收到的信息
def callback(ch, method, properties, body):
    global receive_num
    print("第{}次接收数据：{}".format(receive_num, body))
    receive_num += 1
    time.sleep(0.5)


# rabbitmq使用callback来接收信息
channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)

print('Waiting for messages. To exit press CTRL+C')

# 开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。
channel.start_consuming()
```

![image-20191127225340606](assets/image-20191127225340606.png)

### 效果

发送方

![image-20191127224530028](assets/image-20191127224530028.png)

RabbitMQ

![image-20191127224550219](assets/image-20191127224550219.png)

注意：因为刚刚是先让生产者运行，当我们再让一个消费者运行时，它会一次性的将所有的任务都领取了，导致第2个消费者拿不到任务，因此下面的测试，改为先让2个消费者运行，然后再让生产者运行

消费者1：

![image-20191127225136214](assets/image-20191127225136214.png)

消费者2： ![image-20191127225149289](assets/image-20191127225149289.png)

可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。

## 4. 消息确认机制

通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。

当`autoAck=true`时，一旦消费者接收到了消息，就视为自动确认了消息。如果消费者在处理消息的过程中，出了错，就没有什么办法重新处理这条消息，所以我们很多时候，需要在消息处理成功后，再确认消息，这就需要手动确认。

那么问题来了：RabbitMQ怎么知道消息被接收了呢？

这就要通过消息确认机制（Acknowlege）来实现了。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：

- 自动ACK：消息一旦被接收，消费者自动发送ACK
- 手动ACK：消息接收后，不会发送ACK，需要手动调用

大家觉得哪种更好呢？

这需要看消息的重要性：

- 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便
- 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。

我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码：

```
ch.basic_ack(delivery_tag=method.delivery_tag)  # 给rabbitmq返回已拿到数据信号
auto_ack=False
```

位置如下：

![image-20191127232904826](assets/image-20191127232904826.png)

## 5. 能者多劳

### 5.1 问题

刚才的实现有问题吗？

- 消费者1比消费者2的效率要低，一次任务的耗时较长
- 然而两人最终消费的消息数量是一样的
- 消费者2做完了25次消费之后，大量时间处于空闲状态，消费者1一直忙碌

现在的状态属于是把任务的数量做到了平均分配，但没有做到任务量的平均分配，正确的做法应该是消费越快，消费的越多。

#### 大体方式

想要实现公平调度，使用`basic_qos`设置`prefetch_count=1`，使得`rabbitmq`不会在同一时间给工作者分配多个任务，即只有工作者完成任务之后，才会再次接收到任务

```python
channel.basic_qos(prefetch_count=1)
```

### 5.2 实现

怎么实现呢？

我们可以修改设置，让消费者同一时间只接收一条消息，这样处理完成之前，就不会接收更多消息，就可以让处理快的人，接收更多消息 

消费者1

![image-20191127232128286](assets/image-20191127232128286.png)

消费者2

![image-20191127232058145](assets/image-20191127232058145.png)

再次测试：

![image-20191127232304122](assets/image-20191127232304122.png)

![image-20191127232328313](assets/image-20191127232328313.png)

## 6. 总结

1. 正常情况下如果一个队列有多个消费者，RabbitMQ是按照任务数进行平均分配，例如有10个任务，每个消费者各5个，而不管每个任务的时间长短是否一样
2. 如果想要实现真正平均分配任务，应该是从任务总耗时来考虑，即如果有10个任务，其中有8个任务时间很短，有2个任务时间较长，但是8个较短的任务耗时与2个较长任务耗时差不多，此时最好让RabbitMQ做到这样的分配才算合理
3. 实现平均分配的方式是
   1. 设置`channel.basic_qos(prefetch_count=1)`
   2. 设置自动应答