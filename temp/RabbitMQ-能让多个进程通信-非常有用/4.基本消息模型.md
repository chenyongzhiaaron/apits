# 基本消息模型

## 1. MQ简单说明

RabbitMQ是一个消息的代理者（Message Broker）：它接收消息并且传递消息。

你可以认为它是一个邮局：当你投递邮件到一个邮箱，你很肯定邮递员会终究会将邮件递交给你的收件人。与此类似，RabbitMQ 可以是一个邮箱、邮局、同时还有邮递员。

不同之处在于：RabbitMQ不是传递纸质邮件，而是二进制的数据

## 2. 基本消息模型

示例图如下：

![1527070619131](assets/1527070619131.png)

说明：

- P：生产者，也就是要发送消息的程序
- C：消费者：消息的接受者，会一直等待消息到来。
- queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。

## 3. demo

使用`rabbitmq`实现收发消息，创建两个py文件，一个`send.py`发送“life is short, I use Python!”到`rabbitmq`（其实就是我们刚刚使用Docker运行起来的RabbitMQ服务），一个`receive.py`从`rabbitmq`中接受发送方发送的信息。

### 3.1 发送方(生产者)

`send.py`代码如下：

```python
import pika

# 无论是生产者还是消费者，都需要和 RabbitMQ Broker 建立连接
# 发送给某个用户，需要写用户IP，此处发给本机，使用localhost
# Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))

# 创建一个通道，Channel是在connection内部建立的逻辑连接
channel = connection.channel()

# 声明消息队列，消息将在这个队列中传递。如果消息发送给不存在的队列，rabbitmq将会自动清除这些信息
channel.queue_declare(queue='hello')

# 发送消息到声明的hello队列，其中exchange表示交换器，能够精准指定消息发送到那个队列，routing_key设置为队列的名称，body就是发送的内容。
channel.basic_publish(exchange='', routing_key='hello', body='Life is short, I use Python!')

print("Sent Life is short, I use Python! ----OK")

# 关闭连接
connection.close()
```

控制台：

![image-20191127221839407](assets/image-20191127221839407.png)

#### web控制台查看消息

进入队列页面，可以看到新建了一个队列：`hello`

![image-20191127221459301](assets/image-20191127221459301.png)

点击队列名称，进入详情页

![image-20191127221613661](assets/image-20191127221613661.png)

可以查看消息：

![1527072746634](assets/image-20191127221714271.png)

在控制台查看消息并不会将消息消费，所以消息还在。

### 3.2 接收方(消费者):

`receive.py`代码如下：

```python
import pika

# 建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
# 建立通道
channel = connection.channel()
# 声明消息队列
channel.queue_declare(queue='hello')


# 定义回调函数，处理接收到的信息
def callback(ch, method, properties, body):
    print("Received {}".format(body))


# rabbitmq使用callback来接收信息
channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)

print('Waiting for messages. To exit press CTRL+C')

# 开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。
channel.start_consuming()
```

执行`receive.py` 就能够接收到`hello`队列中发送的信息，再编写一个发送程序，再次执行，会看到接收端又接收到一条信息。

控制台：

![image-20191127222425714](assets/image-20191127222425714.png)

这个时候，队列中的消息就没了：

![image-20191127222446906](assets/image-20191127222446906.png)

#### 注意：

仔细观察接收者，其实并没有退出程序，此时它正在等待其他消息的到来。为了验证，可以再次运行发送数据的代码，效果如下：

![image-20191127222736358](assets/image-20191127222736358.png)

## 4. 总结

基本消息模型中，我们主要学到的是

- 发送方可以将数据成功发送给broker
- broker接收到数据后，如果没有接收者，那么就暂时存储
- 当有消费者（其实就是接收者）需要消费数据时，就会将其拿走，此时broker中这个消息就被消费了

之前就说过，MQ就是典型的`生产者、消费者`模型，我们也可以得出一些经验，此时的收发双方已经被真正的“解耦”了，发送方不需要等待接收方拿到这这个数据之后再去做什么，而是发送完毕之后就可以做起来，这种思想在很多工作的项目中被应用到，希望各位同学注意。