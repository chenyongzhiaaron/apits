# 反序列化操作

**本小节学习目标**：
* 掌握反序列化-数据校验的基本使用
* 掌握反序列化-补充校验的3种方式
* 掌握反序列化-数据保存(create和update)

### 1. 数据校验

#### 1.1 基本使用

```python
# 1. 创建序列化器对象
serializer = 序列化器类(data=<待校验字典数据>)

# 2. 数据校验：成功返回True，失败返回False
serializer.is_valid()

# 3. 获取校验成功之后的数据
serializer.validated_data

# 4. 如果校验失败，获取失败的错误提示信息
serializer.errors
```
> 注：调用is_valid时，会根据对应序列化类字段是否需要传递、字段类型以及一些选项参数对data中的数据进行校验。

如：
```python
from booktest.serializers import BookInfoSerializer

data = {'btitle': 'python', 'bpub_date': '2019-06-01'}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回True
serializer.errors  # {}
serializer.validated_data  
#  OrderedDict([
#   ('btitle', 'python'),
#   ('bpub_date', datetime.datetime(2019, 06, 01))
#  ])

data = {'btitle': 'python', 'bpub_date': 123}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回False
serializer.errors
# {
#   'bpub_date': [ErrorDetail(string='Date has wrong format. Use one of these formats instead: YYYY[-MM[-DD]].', code='invalid')]
# }
serializer.validated_data # {}
```

#### 1.2 补充验证

在调用is_valid进行数据校验时，除了一些基本的默认验证行为，可能还需要补充一些验证行为，比如有如下需求：

1）在进行btitle验证时，要求btitle的内容必须含有`django`。

2）在进行bread和bcomment验证时，要求bread必须大于等于bcomment。

需要再补充验证行为，可以使用以下三种方法：

1）**validators**

**针对指定序列化器字段添加validators选项参数补充校验**，如：

```python
def about_django(value):
    if 'django' not in value.lower():
        raise serializers.ValidationError("图书不是关于Django的")
    return value

class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    id = serializers.IntegerField(label='ID', read_only=True)
    btitle = serializers.CharField(label='名称', max_length=20, validators=[about_django])
    bpub_date = serializers.DateField(label='发布日期')
    bread = serializers.IntegerField(label='阅读量', required=False)
    bcomment = serializers.IntegerField(label='评论量', required=False)
```

测试：

```python
from booktest.serializers import BookInfoSerializer
data = {'btitle': 'python', 'bpub_date': '2019-06-01'}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回False   
serializer.errors
#  {'btitle': [ErrorDetail(string='图书不是关于Django的', code='invalid')]}
```

 2）**`validate_<field_name>`**

 **在序列化器类中定义特定方法`validate_<field_name>`，针对特定字段进行补充验证**，如：

```python
class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    ...

    def validate_btitle(self, value):
        if 'django' not in value.lower():
            raise serializers.ValidationError("图书不是关于Django的")
        return value
```

测试：

```python
from booktest.serializers import BookInfoSerializer
data = {'btitle': 'python', 'bpub_date': '2019-06-01'}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回False   
serializer.errors
#  {'btitle': [ErrorDetail(string='图书不是关于Django的', code='invalid')]}
```

3）**validate**

**在序列化器类中定义`validate`方法针对多个字段的内容进行补充验证**，如：

```python
class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    ...

    def validate(self, attrs):
        bread = attrs['bread']
        bcomment = attrs['bcomment']
        if bread < bcomment:
            raise serializers.ValidationError('阅读量小于评论量')
        return attrs
```

测试：

```python
from booktest.serializers import BookInfoSerializer
data = {'btitle': 'Django入门', 'bpub_date': '2019-06-01', 'bread': 10, 'bcomment': 20}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回False
serializer.errors
#  {'non_field_errors': [ErrorDetail(string='阅读量小于评论量', code='invalid')]}
```

### 2. 数据保存

1）在数据校验通过之后，想要基于validated_data完成数据的保存，可以通过`序列化器对象.save()`进行数据的保存。

2）在save方法内部会调用序列化器类的create或update方法，可以在create方法中实现数据新增，update方法中实现数据更新。

3）创建序列化器对象的时候，如果没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。

如：

```python
class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    ...

	def create(self, validated_data):
        """新建"""
        book = BookInfo.objects.create(**validated_data)
        return book

    def update(self, instance, validated_data):
        """更新，instance为要更新的对象实例"""
        instance.btitle = validated_data.get('btitle', instance.btitle)
        instance.bpub_date = validated_data.get('bpub_date', instance.bpub_date)
        instance.save()
        return instance
```



```python
from booktest.serializers import BookInfoSerializer
from booktest.models import BookInfo

# 1. 图书新增
data = {'btitle': '封神演义', 'bpub_date': '1990-10-10'}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # True
serializer.save()  # 调用序列化器类的create方法，实现图书的新增
serializer.data # 获取新增图书序列化之后的数据

# 2. 图书更新
book = BookInfo.objects.get(id=2)
data = {'btitle': '倚天剑', 'bpub_date': '1989-01-01'}
serializer = BookInfoSerializer(book, data=data)
serializer.is_valid()  # True
serializer.save()  # 调用序列化器类的update方法，实现图书的更新
serializer.data # 获取更新图书序列化之后的数据
```

**总结**：
* 反序列化-基本校验
  * 创建序列化器对象，将字典数据传递给data，调用序列化器的is_valid方法进行数据校验
* 反序列化-补充校验
  * 针对指定字段添加validators选项参数添加补充验证函数
  * 在序列化器类中定义特定方法`validate_<field_name>`针对特定字段进行补充验证
  * 在序列化器类中定义方法`validate`进行补充验证
* 反序列化-数据保存
  * 数据校验通过之后，可以调用序列化对象的save方法进行数据保存
  * save方法内部会调用对应序列化器类中的create或update方法，可以在create中实现数据新增，在update中实现数据更新
