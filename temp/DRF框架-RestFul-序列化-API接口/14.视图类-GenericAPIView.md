# GenericAPIView

**本小节目标**：
* 理解GenericAPIView和APIView的区别
* 掌握GenericAPIView的基本使用
* 掌握使用GenericAPIView改写图书管理RestAPI

## GenericAPIView特点

`GenericAPIView`与`APIView`的不同之处在于：
* 继承自`APIView`，在APIView功能基础上，**主要增加了操作序列化器和数据库查询的属性和方法**。

> 注：GenericAPIView为之后要学的Mixin扩展类的执行提供方法支持，通常在使用时，可搭配一个或多个Mixin扩展类。

### 1. 提供的关于序列化器使用的属性与方法

* 属性：

  * **serializer_class**：指明视图使用的序列化器

* 方法：

  * **get_serializer_class(self)**   

    返回序列化器类，默认返回`serializer_class`，可以重写。

  * **get_serializer(self, *args, *****kwargs)

    返回创建序列化器类的对象，如果我们在视图中想要创建序列化器对象，可以直接调用此方法。

```python
  from booktest.serializers import BookInfoSerializer

  class BookListView(GenericAPIView):
      serializer_class = BookInfoSerializer
```

### 2. 提供的关于数据库查询的属性与方法

* 属性：

  * **queryset**：指明视图使用的查询集

* 方法：

  * **get_queryset(self)**

    返回视图使用的查询集，默认返回`queryset`属性，可以重写。

  * **get_object(self)**

    返回从视图使用的查询集中查询指定的对象(默认根据url地址中提取的pk进行查询)，如查询不到，此方法会抛出Http404异常。

```python
  from booktest.models import BookInfo

  class BookListView(GenericAPIView):
    queryset = BookInfo.objects.all()
```

### 3. 其他可以设置的属性

* **pagination_class**：指明分页控制类
* **filter_backends**：指明过滤控制后端

### 4. 案例-使用GenericAPIView改写RestAPI

使用GenericAPIView进一步改写APIView改写之后的RestAPI。

```python
# views.py
from rest_framework.generics import GenericAPIView
from rest_framework import status

from booktest.serializers import BookInfoSerializer
from booktest.models import BookInfo

# /books/
class BookListView(GenericAPIView):
    """
    获取所有图书、增加图书
    """
    # 指定视图所使用的序列化器类
    serializer_class = BookInfoSerializer
    # 指定视图所使用的查询集
    queryset = BookInfo.objects.all()

    def get(self, request):
        """
        获取所有的图书数据
        """
        queryset = self.get_queryset()

        # 序列化所有图书数据
        serializer = self.get_serializer(queryset, many=True)

        return Response(serializer.data)

    def post(self, request):
        """
        新增一个图书数据
        """
        # 反序列化-数据校验
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # 反序列化-数据保存(save内部会调用序列化器类的create方法)
        serializer.save()

        return Response(serializer.data, status=status.HTTP_201_CREATED)

# /books/(?P<pk>\d+)/
class BookDetailView(GenericAPIView):
    """
    获取、修改、删除指定图书
    """
    # 指定视图所使用的序列化器类
    serializer_class = BookInfoSerializer
    # 指定视图所使用的查询集
    queryset = BookInfo.objects.all()

    def get(self, request, pk):
        """
        获取指定图书
        """
        instance = self.get_object()

        # 将图书数据进行序列化
        serializer = BookInfoSerializer(instance)

        return Response(serializer.data)

    def put(self, request, pk):
        """
        修改指定图书
        """
        instance = self.get_object()

        # 反序列化-数据校验
        serializer = BookInfoSerializer(instance, data=request.data)
        serializer.is_valid(raise_exception=True)

        # 反序列化-数据保存(save内部会调用序列化器类的update方法)
        serializer.save()

        return Response(serializer.data)

    def delete(self, request, pk):
        """
        删除指定图书：
        """
        instance = self.get_object()
        instance.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

> 思考：
> 1. 继承于GenericAPIView之后，图书管理每个API接口中的代码和视图中指定的serializer_class和queryset还有没有直接的关系？
> 2. 如果将BookListView中的serializer_class=HeroInfoSerializer、queryset=HeroInfo.objects.all()，那么BookListView中的两个API接口的功能变为了什么？

**总结**：
* GenericAPIView和APIView的区别：
  * 继承自APIView
  * 封装了操作序列化器的属性和方法
    * 属性：serializer_class
    * 方法：get_serializer_class和get_serializer
  * 封装了数据库操作的属性和方法
    * 属性：queryset
    * 方法：get_queryset和get_object
  * 其他：过滤和分页
