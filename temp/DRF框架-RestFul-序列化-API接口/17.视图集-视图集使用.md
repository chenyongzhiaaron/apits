# 视图集ViewSet

**本小节目标**：
* 掌握视图集的特点和基本使用
* 掌握视图集父类GenericViewSet和ModelViewSet的使用
* 掌握视图集中添加额外的处理函数(API接口)
* 了解视图集对象action属性的作用及使用场景

## 视图集

视图集：**将操作同一组资源相关的处理方法放在同一个类中，这个类叫做视图集**。如：

前面在实现图书管理的5个API时，需要两个类视图，而如果视图集，只需要一个即可。

### 1. 基本使用

1）继承视图集父类ViewSet(继承自ViewSetMixin和APIView)。

2）视图集中的处理方法不再以对应的请求方式(get、post等)命名，而是以对应的操作(action)命名。

* list：获取一组数据
* create：新增一条数据
* retrieve：获取指定的数据
* update：更新指定的数据
* destroy：删除指定的数据

3）在进行URL配置时，需要明确指明某个请求方式请求某个URL地址时，对应的是视图集中的哪个处理函数。

如：
```python
import json
from rest_framework import viewsets

from booktest.models import BookInfo
from booktest.serializers import BookInfoSerializer

class BookInfoViewSet(viewsets.ViewSet):
    def list(self, request):
        books = BookInfo.objects.all()
        serializer = BookInfoSerializer(books, many=True)
        return Response(serializer.data)

    def create(self, request):
        serializer = BookInfoSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def retrieve(self, request, pk):
        try:
            book = BookInfo.objects.get(id=pk)
        except BookInfo.DoesNotExist:
            raise Http404

        serializer = BookInfoSerializer(book)
        return Response(serializer.data)

    def update(self, request, pk):
        try:
            book = BookInfo.objects.get(id=pk)
        except BookInfo.DoesNotExist:
            raise Http404

        serializer = BookInfoSerializer(book, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def destroy(self, request, pk):
      try:
          book = BookInfo.objects.get(id=pk)
      except BookInfo.DoesNotExist:
          raise Http404

      book.delete()
      return Response(status=status.HTTP_204_NO_CONTENT)
```

url的配置：

```python
from booktest import views

urlpatterns = [
    url(r'^books/$', views.BookInfoViewSet.as_view({
        'get':'list',
        'post': 'create'
    })),
    url(r'^books/(?P<pk>\d+)/$', views.BookInfoViewSet.as_view({
        'get': 'retrieve',
        'put': 'update',
        'delete': 'destroy'
    }))
]
```

### 2. 常用视图集父类

1） ViewSet

继承自`APIView`与`ViewSetMixin`，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。

2）GenericViewSet

继承自`GenericAPIView`与`ViewSetMixin`，可以直接搭配Mixin扩展类使用。

如：

```python
from rest_framework import mixins
from rest_framework.viewsets import GenericViewSet

class BookInfoViewSet(mixins.ListModelMixin,
                      mixins.CreateModelMixin,
                      mixins.RetrieveModelMixin,
                      mixins.UpdateModelMixin,
                      mixins.DestroyModelMixin,
                      GenericViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
```

url的配置：
```python
from booktest import views

urlpatterns = [
    url(r'^books/$', views.BookInfoViewSet.as_view({
        'get':'list',
        'post': 'create'
    })),
    url(r'^books/(?P<pk>\d+)/$', views.BookInfoViewSet.as_view({
        'get': 'retrieve',
        'put': 'update',
        'delete': 'destroy'
    }))
]
```

3）ModelViewSet

继承自`GenericViewSet`，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestroyModelMixin。

如：
```python
from rest_framework import mixins
from rest_framework.viewsets import ModelViewSet

class BookInfoViewSet(ModelViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
```

url的配置：
```python
from booktest import views

urlpatterns = [
    url(r'^books/$', views.BookInfoViewSet.as_view({
        'get':'list',
        'post': 'create'
    })),
    url(r'^books/(?P<pk>\d+)/$', views.BookInfoViewSet.as_view({
        'get': 'retrieve',
        'put': 'update',
        'delete': 'destroy'
    }))
]
```

4）ReadOnlyModelViewSet

继承自`GenericViewSet`，同时包括了ListModelMixin、RetrieveModelMixin。

###  3. 视图集中添加额外的处理方法(API)

在视图集中，除了上述默认的action处理方法(API)之外，还可以添加额外的处理方法(API)。

**需求**：

在图书管理API接口中，除5个基本API接口之后，再添加另外2个接口：
* 获取ID最新的一本图书的数据
* 修改指定图书的阅读量(只修改阅读量)

如：

```python
from rest_framework import mixins
from rest_framework.viewsets import GenericViewSet
from rest_framework.decorators import action

class BookInfoViewSet(ModelViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def latest(self, request):
        """
        返回id最新的图书信息
        """
        book = BookInfo.objects.latest('id')
        serializer = self.get_serializer(book)
        return Response(serializer.data)

    def read(self, request, pk):
        """
        修改指定图书的阅读量
        """
        book = self.get_object()
        book.bread = request.data.get('read')
        book.save()
        serializer = self.get_serializer(book)
        return Response(serializer.data)
```

url的配置：

```python
urlpatterns = [
    url(r'^books/$', views.BookInfoViewSet.as_view({
        'get':'list',
        'post': 'create'
    })),
    url(r'^books/(?P<pk>\d+)/$', views.BookInfoViewSet.as_view({
        'get': 'retrieve',
        'put': 'update',
        'delete': 'destroy'
    }))
    url(r'^books/latest/$', views.BookInfoViewSet.as_view({
        'get': 'latest'
    })),
    url(r'^books/(?P<pk>\d+)/read/$', views.BookInfoViewSet.as_view({
        'put': 'read'
    }))
]
```

### 4. 视图集对象action属性

在视图集中，可以通过`视图集对象.action`获取所有执行action的操作。

应用场景：重写get_serializer_class和get_queryset，根据不同的action操作返回不同的序列化器类和不同的查询集。

如：

```python
def get_serializer_class(self):
    if self.action == 'list':
        return '<list操作所使用的序列化器类>'
    else:
        return '<其他操作所使用的序列化器类>'

def get_queryset(self):
    if self.action == 'list':
        return '<list操作所使用的查询集>'
    else:
        return '<其他操作所使用的查询集>'
```

**总结**：
* 视图集基本使用
  * 继承视图集父类ViewSet
  * 视图集中的处理方法不再以请求方法(get等)命名，而是以对应的action操作命名
  * url地址配置时需要明确指明请求方式和处理函数之间的对应关系
* 视图时父类的使用
  * GenericViewSet：配合Mixin扩展类提供对应请求处理方法
  * ModelViewSet：继承自GenericViewSet和5个Mixin扩展类
  * ReadOnlyModelViewSet：继承自GenericViewSet和2个Mixin扩展类
* 视图集中添加额外的处理方法(API接口)：
  * 在视图集类中直接添加即可，添加之后也需要进行url地址配置
* 视图集对象的action属性
  * 获取所要执行的action操作
