# 链表应用-LRU 缓存

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。

### 常见的缓存淘汰策略

- 先进先出策略  FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略  LRU（Least Recently Used）

**假如你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？**



### LRU缓存的实现

**思路**：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表：

1. 如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中,，则将此结点插入到链表的头部；

   - 如果此时缓存超过容量，则链表尾结点删除。



```python
class ListNode:
    def __init__(self, item):
        self.item = item
        self.next = None


class LRUCache:
    """
    一个 LRU 缓存
    维护了一个有序单链表，越靠近链表尾部的结点是越早之前访问的。
    """

    def __init__(self, capacity=10):
        self.__cap = capacity  # 容量
        self.__head = None
        self.__length = 0

    def __len__(self):
        return self.__length

    def __str__(self):
        vals = []
        temp = self.__head
        while temp != None:
            vals.append(str(temp.item))
            temp = temp.next
        return '->'.join(vals)

    def get_val(self, val):
        """
        获取指定缓存数据
        思路：从链表头开始顺序遍历链表：
        1. 如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
        2. 如果此数据没有在缓存链表中，则将新的数据结点插入链表的头部：
           - 如果此时缓存已满已超过容量，则将链表尾结点删除，
        参数：
            val:要获取的数据
        返回：
            存在于缓存中，返回True，否则返回 False。
        """
        temp = self.__head
        prev = None
        while temp != None:
            if temp.item == val:
                if temp == self.__head:
                    # 如果是头节点, 什么也不做
                    pass
                else:
                    prev.next = temp.next
                    self.__length -= 1
                    temp.next = self.__head
                    self.__head = temp
                    self.__length += 1
                
                break

            prev = temp
            temp = temp.next
        else:
            # 如果没有找到数据，则插入这个新数据
            self.insert_to_head(val)

    def insert_to_head(self, val):
        """将指定节点插入到头部"""
        if self.__length >= self.__cap:
            # 如果已经满了, 则删除最后一个节点，添加新节点到头
            # 找到最后一个节点，将其移除
            temp = self.__head
            prev = None
            while temp.next != None:
                prev = temp
                temp = temp.next
            prev.next = None  # 最后第2个节点，设置为最后1个节点
            self.__length -= 1  # 更新节点个数

        # 添加新节点到头
        # 创建新节点
        new_node = ListNode(val)
        # 插入到头
        new_node.next = self.__head
        self.__head = new_node
        # 更新节点可数
        self.__length += 1


if __name__ == "__main__":
    # 创建一个缓存对象
    lru_cache = LRUCache(4)

    # 添加数据
    # lru_cache.insert_to_head(11)
    # lru_cache.insert_to_head(22)
    # lru_cache.insert_to_head(33)
    # lru_cache.insert_to_head(44)

    # print(lru_cache)
    # print(len(lru_cache))

    # 获取数据
    lru_cache.get_val(11)
    lru_cache.get_val(22)
    lru_cache.get_val(33)

    print(lru_cache)
    print(len(lru_cache))

    lru_cache.get_val(88)
    print(lru_cache)
    print(len(lru_cache))

    lru_cache.get_val(11)
    print(lru_cache)
    print(len(lru_cache))

```

运行效果：

```
33->22->11
3
88->33->22->11
4
11->88->33->22
4
```

