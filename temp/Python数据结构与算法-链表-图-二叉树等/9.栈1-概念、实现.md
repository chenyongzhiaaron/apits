# 理解“栈”

## “栈”的基本结构

**后进者先出，先进者后出，LIFO，就是典型的“栈”结构。**

![1570433001763](assets/1570433001763.png)

从栈的操作特性上来看，**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。

从功能上来说，数组或链表可以替代栈，但特定的数据结构是对特定场景的抽象，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。

**当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，就应该首选“栈”这种数据结构**。



## 实现一个“栈”

栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。

栈既可以用数组来实现，也可以用链表来实现。

用数组实现的栈，我们叫作**顺序栈**，用链表实现的栈，我们叫作**链式栈**。

说明：

* 因为Python中没有数组，我们就用列表来模拟即可，如果想真正用数组来实现，可以考虑用C、C++等实现

#### Python列表实现：

```python
class ArrayStack:
    """
    使用Python中的列表模拟数组，实现顺序栈
    """

    def __init__(self, n=10):
        self.n = n  # 栈的总容量
        self.items = [None] * n  # 创建n个空间组成的栈
        self.count = 0  # 当前栈中数据的个数

    def __str__(self):
        return "栈底 " + str(self.items[:self.count]) + " 栈顶"

    def push(self, item):
        """
        压入新数据
        """
        # 判断栈是否已经满了
        if self.count == self.n:
            return False

        # 如果栈没有满
        self.items[self.count] = item
        self.count += 1

    def pop(self):
        """
        弹出栈顶数据
        """
        # 判断栈是否为空
        if self.count == 0:
            return False

        # 如果栈不是空
        self.count -= 1
        return self.items[self.count]


if __name__ == "__main__":
    # 创建一个栈对象
    array_stack = ArrayStack(5)

    # 压栈
    array_stack.push(11)
    array_stack.push(22)
    array_stack.push(33)
    array_stack.push(44)
    array_stack.push(55)
    # array_stack.push(66)  # 压入栈 失败，因为已经满了

    # 遍历
    print(array_stack)

    # 弹栈
    print("弹出的数据: ", array_stack.pop())
    print("弹出的数据: ", array_stack.pop())

    # 遍历
    print(array_stack)

    # 压入新数据
    array_stack.push(66)

    # 遍历
    print(array_stack)

```

运行效果：

```
栈底 [11, 22, 33, 44, 55] 栈顶
弹出的数据:  55
弹出的数据:  44
栈底 [11, 22, 33] 栈顶
栈底 [11, 22, 33, 66] 栈顶
```





#### Python链表实现：

```python
class LinkNode:
    def __init__(self, item):
        self.item = item
        self.next = None


class LinkStack:
    """
    使用python中的链表实现 栈（链式栈）
    """

    def __init__(self):
        self.__top = None

    def __str__(self):
        temp = []
        p = self.__top
        while p is not None:
            temp.append(str(p.item))
            p = p.next
        return "->".join(temp)

    def push(self, item):
        """
        压入栈
        :return:
        """
        # 创建一个节点，存储这个数据
        new_node = LinkNode(item)
        new_node.next = self.__top
        self.__top = new_node

    def pop(self):
        """
        弹出栈
        """
        # 如果栈为空
        if not self.__top:
            return False
        # 如果栈不为空
        val = self.__top.item
        self.__top = self.__top.next
        return val


if __name__ == "__main__":
    # 创建一个栈
    link_stack = LinkStack()

    # 压栈
    link_stack.push(11)
    link_stack.push(22)
    link_stack.push(33)
    link_stack.push(44)
    link_stack.push(55)

    # 遍历
    print("栈顶", link_stack, "栈底")

    # 弹栈
    print("弹出的数据: ", link_stack.pop())

    # 遍历
    print("栈顶", link_stack, "栈底")

    # 压栈
    link_stack.push(66)

    # 遍历
    print("栈顶", link_stack, "栈底")

```

运行效果：

```
栈顶 55->44->33->22->11 栈底
弹出的数据:  55
栈顶 44->33->22->11 栈底
栈顶 66->44->33->22->11 栈底
```



#### 注意

* 不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作


