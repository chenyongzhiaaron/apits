# 栈实现表达式求值

编译器如何利用栈来实现**表达式求值**？比如：`34+13*9+44-12/3`

需要两个栈来实现：一个栈保存操作数，另一个栈保存运算符。

从左向右遍历表达式，遇到数字就压入操作数栈；

遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

下图是`3+5*8-6` 这个表达式的计算过程：

![1570433133761](assets/1570433133761.png)



参考答案：

```python
class ListNode:
    def __init__(self, data: int, next=None):
        self._data = data
        self._next = next


class LinkedStack:
    """基于单链表实现的栈
    """

    def __init__(self):
        self._top: ListNode = None

    def push(self, value):
        # 添加元素
        new_top = ListNode(value)
        new_top._next = self._top
        self._top = new_top
        return True

    def pop(self):
        # 删除并返回栈顶元素
        if not self._top:
            return False
        value = self._top._data
        self._top = self._top._next
        return value

    def get(self):
        # 获取栈顶元素
        if not self._top:
            return False
        return self._top._data

    def __str__(self) -> str:
        vals = []
        p: ListNode = self._top
        while p:
            vals.append(str(p._data))
            p = p._next
        return '->'.join(vals)


def get_priority(temp_char) -> int:
    # 定义一个四则运算符的优先级
    exp_priority = {
        2: "*/%",
        1: "+-"
    }
    for k, v in exp_priority.items():
        if temp_char in v:
            return k


def cal_val(num1, num2, op):
    if op == "+":
        ret = num2 + num1
    elif op == "-":
        ret = num2 - num1
    elif op == "*":
        ret = num2 * num1
    elif op == "/":
        ret = num2 / num1
    elif op == "%":
        ret = num2 % num1
    else:
        ret = False

    return ret


def cal(exp):
    """
    计算表达式的值
    从左向右遍历表达式，遇到数字就压入【数字栈】；
    遇到运算符，就与【运算符栈】的栈顶元素进行比较。
    如果比【运算符栈】顶元素的优先级高，就将当前运算符压入【运算符栈】；
    如果比【运算符栈】顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从【数字栈】的栈顶取 2 个操作数，然后进行计算，
    再把计算完的结果压入【数字栈】，继续比较。
    """

    # 创建2个栈（一个用来存储数据叫做【数字栈】，一个用来存储运算符叫做【运算符栈】）
    link_stack_1 = LinkedStack()  # 数字栈
    link_stack_2 = LinkedStack()  # 运算符栈

    temp = ""  # 用来暂时存储练连续的数字
    exp_len = len(exp)  # 计算出表达式中字符的个数
    i = 0
    while i != exp_len:
        cur_char = exp[i]
        if cur_char.isdigit():  # 如果取出的是数字
            temp += cur_char
            if i == exp_len - 1:  # 如果是整个表达式中的最后一个，那么就压栈
                link_stack_1.push(int(temp))
                break
        else:
            # 将temp存储的字符数字，转换为真正的数据数字
            # 例如 temp = "34"，操作之后 为 整数34
            link_stack_1.push(int(temp))
            temp = ""  # 清空字符串，以便下次使用
            while True:
                # 判断 【运算符栈】的 栈顶操作符与当前操作符的优先级
                link_stack_2_top = link_stack_2.get()
                # 如果【运算符栈】 有数据，那么就进行优先级的大小的判断
                if link_stack_2_top:
                    if get_priority(cur_char) > get_priority(link_stack_2_top):
                        # 如果当前获取的操作符的优先级高于 【运算符栈】中的 栈顶 操作符的优先级
                        link_stack_2.push(cur_char)
                        break
                    else:
                        # 如果运算符低于【运算符栈】顶的优先级，则从【运算符栈】中取栈顶运算符，从【数字栈】的栈顶取 2 个操作数，然后进行计算
                        num1 = link_stack_1.pop()
                        num2 = link_stack_1.pop()
                        op = link_stack_2.pop()
                        ret = cal_val(num1, num2, op)
                        # 把刚刚计算的结果存储到【数字栈】中
                        link_stack_1.push(ret)
                else:
                    # 如果 【运算符栈】 为空，那么就添加当前获取的操作符
                    link_stack_2.push(cur_char)
                    break
        i += 1

    ret = 0
    while True:
        # 如果运算符低于【运算符栈】顶的优先级，则从【运算符栈】中取栈顶运算符，从【数字栈】的栈顶取 2 个操作数，然后进行计算
        num1 = link_stack_1.pop()
        num2 = link_stack_1.pop()
        op = link_stack_2.pop()
        if not op:
            break
        ret = cal_val(num1, num2, op)

        # 把刚刚计算的结果存储到【数字栈】中
        link_stack_1.push(ret)

    return ret


if __name__ == "__main__":
    # 表达式
    exp = "3+5*8-6"

    # 计算表达式的值
    ret = cal(exp)

    # 打印结果
    print("表达式 %s=%s" % (exp, ret))

```

运行结果：

```
表达式 3+5*8-6=37
```

