# 案例3：远程Celery基本使用

## 1. 说明

之前2个案例，虽然我们使用了Celery来实现了异步任务，但是总体来说，依然是在同一台服务器上，实际项目部署时我们肯定是将`worker`部署到另外一台服务器上，此时就需要我们研究怎样快速便捷的完成这样的需求

请看下图，基本展示了远程Celery的使用方式

![image-20191129114723655](assets/image-20191129114723655.png)

## 2. demo

### 2.1 Worker端

`task3.py`文件内容如下：

```python
from celery import Celery

app = Celery(
    'task3',  # 当前模块的名字
    broker='amqp://guest@localhost//',  # 消息队列的url
    # backend='amqp://guest@localhost//',  # 将调用的结果存储到MQ中
    backend='redis://localhost:6379/8'  # 将调用的结果存储到Redis中
)


@app.task
def add(x, y):
    return x + y
```

### 2.2 客户端

`main3.py`文件内容如下：

```python
from celery import Celery

app = Celery(
    broker='amqp://guest@localhost//',  # 消息队列的url
    # backend='amqp://guest@localhost//',  # 将调用的结果存储到MQ中
    backend='redis://localhost:6379/8'  # 将调用的结果存储到Redis中
)

# send_task在发送的时候是不会检查tasks3.add函数是否存在的，即使为空也会发送成功，所以celery执行是可能找不到该函数报错；
ret = app.send_task('task3.add', args=[3, 4])

print(ret)

print(ret.get(timeout=1))
```

## 2.3 运行&测试

#### `task3.py`的运行

使用如下命令将`task3.py`运行在另外一个台服务器上

```shell
$ celery -A task3 worker --loglevel=info
```

#### `main3.py`的运行

在另外一台服务器上，使用Python解释器运行`main3.py`

```shell
python3 main3.py
```

#### 运行结果：

客户端效果

![image-20191129131939337](assets/image-20191129131939337.png)

backend效果

![image-20191129132026171](assets/image-20191129132026171.png)

## 3. 总结

通过上述的案例，想必大家能够清晰的看到远程Celery的使用方式，如果在进一步扩展，就可以借助RabbitMQ添加多个worker，从而实现高可用