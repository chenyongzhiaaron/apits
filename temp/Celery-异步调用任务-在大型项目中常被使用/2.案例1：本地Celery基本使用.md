# 案例1：本地Celery的基本使用

## 1. 介绍

在一个Python进程中发送对“2个数的求和“任务给另外一个进程，让其进行计算

只要能够让另外一个进程执行了任务，就说明Celery具有任务的分发功能

![image-20191129125759461](assets/image-20191129125759461.png)

## 2. 代码实现

### 客户端（即发送任务的一方）

`main.py`代码如下：

```python
from task import add

add.delay(4, 4)
```

### Worker（即执行任务的一方）

`task.py`代码如下：

```python
from celery import Celery

app = Celery(
    'task',  # 任务的名字
    broker='amqp://guest@localhost//'  # 消息队列的url
)


@app.task
def add(x, y):
    return x + y
```

说明：

- `broker`参数可以设置`RabbitMQ`也可以设置为`Redis`。上述代码是使用的`RabbitMQ`，如果中间人想使用`Redis`那么可以设置`broker="redis://localhost"`

## 3. 运行&测试

### 3.1 运行RabbitMQ服务器

为了能够支持Celery的运行，需要将RabbitMQ服务器运行起来（如果忘记请参考之前的RabbitMQ相关课件）

### 3.2 运行客户端

运行`main.py`后，在RabbitMQ中可以看到任务消息，界面如下：

![image-20191129101342412](assets/image-20191129101342412.png)

![image-20191129101715147](assets/image-20191129101715147.png)

### 3.3 运行worker

```shell
$ celery -A task worker --loglevel=info
```

![image-20191129102040397](assets/image-20191129102040397.png)

如果想要查看完整的命令行参数列表

```shell
$  celery worker --help
```

![image-20191129102225719](assets/image-20191129102225719.png)

查看运行结果

![image-20191129102318075](assets/image-20191129102318075.png)