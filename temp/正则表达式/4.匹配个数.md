# 匹配个数

匹配个数的相关格式

|字符|功能|
|:----:|:----|
|*|匹配前一个字符出现0次或者无限次，即可有可无|
|+|匹配前一个字符出现1次或者无限次，即至少有1次|
|?|匹配前一个字符出现1次或者0次，即要么有1次，要么没有|
|{m}|匹配前一个字符出现m次|
|{m,n}|匹配前一个字符出现从m到n次|

## 示例1：*
需求：匹配出，一个字符串第一个字符为为大小英文字母，后面都是小写字母并且这些小写字母可有可无
```python
import re

ret = re.match("[A-Z][a-z]*","M")
print(ret.group())

ret = re.match("[A-Z][a-z]*","MnnM")
print(ret.group())

ret = re.match("[A-Z][a-z]*","Aabcdef")
print(ret.group())

```


运行结果：

```python
M
Mnn
Aabcdef
```


## 示例2：+
需求：匹配出，变量名是否有效
```python
import re

names = ["name1", "_name", "2_name", "__name__"]

for name in names:
    ret = re.match("[a-zA-Z_]+[\w]*",name)
    if ret:
        print("变量名 %s 符合要求" % ret.group())
    else:
        print("变量名 %s 非法" % name)

```


运行结果：

```python
变量名 name1 符合要求
变量名 _name 符合要求
变量名 2_name 非法
变量名 __name__ 符合要求
```


## 示例3：?
需求：匹配出，0到99之间的数字
```python
import re

ret = re.match("[1-9]?[0-9]","7")
print(ret.group())

ret = re.match("[1-9]?\d","33")
print(ret.group())

ret = re.match("[1-9]?\d","09")
print(ret.group())

```

运行结果：

```python
7
33
0  # 这个结果并不是想要的，利用$才能解决
```

## 示例4：{m}

需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线
```python
import re

ret = re.match("[a-zA-Z0-9_]{6}","12a3g45678")
print(ret.group())

ret = re.match("[a-zA-Z0-9_]{8,20}","1ad12f23s34455ff66")
print(ret.group())


```


运行结果：

```python
12a3g4
1ad12f23s34455ff66
```


## 练一练

### 题目1：匹配出163的邮箱地址，且@符号之前有4到20位，例如hello@163.com