# 模板基础

## 1. 回顾

![image-20180813144627689](assets/image-20180813144627689.png)

### 说明

> 上面的示例中，流程很简单，容易理解整个来龙去脉；但是，在处理profile.html页面时，不够完美
>
> 因为：
>
> 需要在html文件中先定义一个独特的标记，然后再通过字符串替换的方式来处理，试想如果一个页面较为复杂，它有用户名、用户的头像、用户近3个月的登录记录、近3个月的浏览记录。。。。这样的话，不说别的
>
> 在处理字符串替换这块就很繁琐，而且不够效率



## 2. Jinja2模板引擎简介(template)

### 模板

视图函数的主要作用是生成请求的响应，这是最简单的请求。

实际上，视图函数有两个作用：

* 处理业务逻辑
* 返回响应内容

在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。

本节学到的模板，它的作用即是承担视图函数的另一个作用，即返回响应内容。

> 模板其实是一个包含响应文本的文件，其中用占位符(变量)表示动态部分，
>
> 告诉模板引擎其具体的值需要从数据中获取
>
> 使用真实值替换变量，再返回最终得到的字符串，这个过程称为“渲染”
>
> Flask是使用 Jinja2 这个模板引擎来渲染模板

### 使用模板的好处：

> 视图函数只负责业务逻辑和数据处理(业务逻辑方面)
>
> 而模板则取到视图函数的数据结果进行展示(视图展示方面)
>
> 代码结构清晰，耦合度低

### Jinja2 两个概念：

> Jinja2：是 Python 下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于 Django 的模板引擎，并扩展了其语法和一系列强大的功能，其是Flask内置的模板引擎
>
> 模板语言：是一种被设计来自动生成文档的简单文本格式
>
> 在模板语言中，一般都会把一些变量传给模板，替换模板的特定位置上预先定义好的占位变量名

### 渲染模版函数

> Flask提供的 render_template 函数封装了该模板引擎
> render_template 函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值。

### 使用

`{{}}` 来表示变量名，这种 `{{}}` 语法叫做`变量代码块`

```html
<h1>{{ user_id }}</h1>
```




## 3. 使用模板引擎升级案例

### 版本1

```python
from flask import Flask
# ==============新添加了===============
from flask import render_template

# 创建flask对象
app = Flask(__name__)

@app.route("/")
def index():
    """
    这个函数用来完成一个url对应的逻辑处理
    :return:
    """
    return "哈哈哈 ，我是第一个flask页面，成功的道理开始了..."

@app.route("/test")
def test():
    return "这是test页面"

@app.route("/profile")
def profile():
    """
    返回html页面数据
    :return:
    """
    # return "<h1>我是个人主页</h1>"
    with open("profile.html") as f:
        content = f.read()
    return content

@app.route("/profile_v2/<user_id>")  # <user_id>表示匹配url时，这里的数据提取出来
def profile_v2(user_id):  # 将提取出来的数据传递给<user_id>中<>内的名字，而且函数的形参也是这个名字
    return "<h1>这是%s的个人主页</h1>" % user_id

@app.route("/profile_v3/<user_id>")
def profile_v3(user_id):
    # return "<h1>这是%s的个人主页</h1>" % user_id
    # 1. 读取profile.html文件
    with open("profile.html") as f:
        content = f.read()

    # 2. 将刚刚标记的那个特殊字符串，进行替换；即将xxxx替换为user_id
    content = content.replace("xxxx", user_id)

    # 3. 将替换之后的HTML页面数据返回，浏览器就可以看到自己个人简历了
    return content

# ==============新添加了函数profile_v4===============
@app.route("/profile_v4/<user_id>")
def profile_v4(user_id):
    return render_template("profile.html")

if __name__ == '__main__':
    app.run()

```



![image-20180813150309131](assets/image-20180813150309131.png)

![image-20180813150415803](assets/image-20180813150415803.png)

### 版本2

![image-20180813150615504](assets/image-20180813150615504.png)

![image-20180813150828603](assets/image-20180813150828603.png)

![image-20180813150934898](assets/image-20180813150934898.png)

![image-20180813151034126](assets/image-20180813151034126.png)

![image-20180813151143001](assets/image-20180813151143001.png)

![image-20180813151208714](assets/image-20180813151208714.png)

![image-20180813151250268](assets/image-20180813151250268.png)

#### 重新运行flask工程，然后浏览器重新访问

![image-20180813151332614](assets/image-20180813151332614.png)



### 版本3

> 上面的示例已经能够看到只需要一句render_template就可以完成打开profile.html以及读取其内容的功能，非常方便
>
> 但是发现了另外一个问题，上图中的xxxx并不是咱们想要的

![image-20180813151634582](assets/image-20180813151634582.png)

#### 修改`render_template`函数

![image-20180813151831587](assets/image-20180813151831587.png)

#### 修改`profile.html`

![image-20180813152038250](assets/image-20180813152038250.png)

#### 重启flask工程，浏览器重新访问

![image-20180813152117005](assets/image-20180813152117005.png)

#### 小总结

![image-20180813160348136](assets/image-20180813160348136.png)