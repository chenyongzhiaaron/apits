# `__getattr__`和`__getattribute__`

## 1. `__getattr__`

`__getattr__`在当前主流的Python版本中都可用，重写`__getattr__`方法对类及其实例`未定义的属性`有效

也就属性是说，如果访问的属性存在，就不会调用`__getattr__`方法

这个属性的存在，包括类属性和实例属性



Python官方文档的定义

> Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for `self`). `name` is the attribute name.

 

```python
class ClassA:
    x = 'a'
    def __init__(self):
        self.y = 'b'
    def __getattr__(self, item):
        return '__getattr__'

if __name__ == '__main__':
    a = ClassA()
    print(a.x)  # a

    # 使用实例对象直接访问实例存在的实例属性时,不会调用__getattr__方法
    print(a.y)  # b

    # 使用实例对象直接访问实例不存在的实例属性时,会调用__getattr__方法
    print(a.z)  # __getattr__

```



## 2.  `__getattribute__`

`__getattribute__`仅在新式类中可用，重写`__getattrbute__`方法对类对象或者实例对象的每个属性访问都有效。

Python官方文档的定义

> Called unconditionally to implement attribute accesses for instances of the class.

示例代码：

```python
class ClassA:
    x = 'a'
    def __init__(self):
        self.y = 'b'
    def __getattribute__(self, item):
        print("__getattribute__被调用...")
        return '__getattribute__'


if __name__ == '__main__':
    a = ClassA()
    # 使用实例对象直接访问存在的类属性时,会调用__getattribute__方法
    print(a.x)  # __getattribute__

    # 使用实例对象直接访问实例存在的实例属性时,会调用__getattribute__方法
    print(a.y)  # __getattribute__

    # 使用实例对象直接访问实例不存在的实例属性时,也会调用__getattribute__方法
    print(a.z)  # __getattribute__

    print(ClassA.x)  # 通过类对象调用属性，不会执行__getattribute__方法
```

运行结果：

```python
__getattribute__被调用...
__getattribute__
__getattribute__被调用...
__getattribute__
__getattribute__被调用...
__getattribute__
a
```

## 3. 同时定义 `__getattribute__`和`__getattr__`

另外，当同时定义`__getattribute__`和`__getattr__`时，`__getattr__`方法不会再被调用，除非显示调用`__getattr__`方法或引发AttributeError异常。

示例代码（`__getattr__`方法不会再被调用）：

```python
class ClassA:
    def __getattr__(self, item):
        print('__getattr__')

    def __getattribute__(self, item):
        print('__getatttribute__')

if __name__ == '__main__':
    a = ClassA()
    a.x

```

运行结果：

```python
__getatttribute__
```

 

## 4. 注意

由于`__getattr__`只针对未定义属性的调用，所以它可以在自己的代码中自由地获取其他属性，而`__getattribute__`针对所有的属性运行，因此要十分注意避免在访问其他属性时，再次调用自身的递归循环。

当在`__getattribute__`代码块中，再次执行属性的获取操作时，会再次触发`__getattribute__`方法的调用，代码将会陷入无限递归，直到Python递归深度限制（重载`__setter__`方法也会有这个问题）

示例代码（无限递归）：

```python
class ClassA:
    x = 'a'
    def __getattribute__(self, item):
        print('__getattribute__')
        return self.item


if __name__ == '__main__':
    a = ClassA()
    a.x

```

运行结果引发异常，提示达到最大递归深度

![image-20190311113826783](./assets/image-20190311113826783.png)



同时，也没办法通过从`__dict__`取值的方式来避免无限递归

```python
class ClassA:
    x = 'a'

    def __getattribute__(self, name):
        return self.__dict__[name]


if __name__ == '__main__':
    a = ClassA()
    # 无限递归
    a.x

```

![image-20190311113855273](./assets/image-20190311113855273.png)

为了避免无限递归，应该把获取属性的方法指向一个更高的超类，例如`object`（因为`__getattribute__`只在新式类中可用，而新式类所有的类都显式或隐式地继承自`object`，所以对于新式类来说，`object`是所有新式类的超类）

修改代码（避免无限递归循环）：

```python
class ClassA:
    x = 'a'

    def __init__(self):
        self.y = "b"

    def __getattribute__(self, item):
        print('__getattribute__')
        return super().__getattribute__(item)


if __name__ == '__main__':
    a = ClassA()
    print(a.x)
    print(a.y)

```

运行结果正常：

![image-20190311114050055](./assets/image-20190311114050055.png)

## 5. 总结

 `__getattribute__`和`__getattr__`都是对访问属性时的特殊操作

* `__getattr__`只针对未定义属性的调用
* `__getattribute__`针对所有的属性运行
