# 内建函数

## 1. 内建函数

### 1.1 什么是内建函数

Build-in Function,启动python解释器，输入`dir(__builtin__)`, 可以看到很多python解释器启动后默认加载的属性和函数，这些函数称之为内建函数

通俗的说：

内建函数通常值得是，我们可以直接使用那些函数，而不是指在类中方法，例如`help`、`len`、`print`等

### 1.2 注意

内建函数因为在编程时使用较多，`cpython解释器`用`c语言`实现了这些函数，启动解释器 时默认加载。

这些函数数量众多，不宜记忆，开发时不是都用到的，待用到时再`help(function)`, 查看如何使用，或结合谷歌查询即可，在这里介绍些常用的内建函数。

## 2. 常用内建函数案例

### 2.1 `range函数`

#### Python2中

`range`会得到一个列表

```python
range(stop) -> list of integers
range(start, stop[, step]) -> list of integers
```

参数说明：

- start:计数从start开始，默认是从0开始。例如`range(5)`等价于`range(0，5)`;
- stop:到stop结束，但不包括stop.例如：`range(0, 5)` 结果是`[0, 1, 2, 3, 4]`没有`5`
- step:每次跳跃的间距，默认为`1`，例如：`range(0,5)` 等价于 `range(0, 5, 1)`



#### Python3中

`Python2`中`range`返回列表，`Python3`中`range`返回一个range对象，是一个可以迭代的对象，可以配合`for`或者`next`等使用

当然了如果想得到列表，可通过list函数

```python
a = range(5)
list(a)
```

创建列表的另外一种方法（列表推导式）

```python
In [21]: testList = [x+2 for x in range(5)]
In [22]: testList
Out[22]: [2, 3, 4, 5, 6]
```

### 2.2 `map函数`

`map函数`会根据提供的`函数`对`指定序列`做`映射`

```python
map(function, sequence[, sequence, ...]) -> list
```

说明：

- function:是一个函数的引用，即`函数名`，而不是`函数名()`
- sequence:是一个或多个序列,取决于function需要几个参数
- 返回值:是一个列表

参数序列中的每一个元素分别调用`function函数`，将每次`function函数`的返回值，存到列表中当做最后的结果

#### 案例1（基本使用）

```python
# 函数需要一个参数
map(lambda x: x*x, [1, 2, 3])
# 结果为:[1, 4, 9]

```

每次从列表`[1, 2, 3]`中提取一个数值，然后当做实参传递到匿名函数中，将这个函数的返回值存储到列表中，

1. 第一次取`[1, 2, 3]`中的第1个数据`1`当做实参传到匿名函数中，将`1*1`存储到列表中，此时列表为`[1]`
2. 第一次取`[1, 2, 3]`中的第2个数据`2`当做实参传到匿名函数中，将`2*2`存储到列表中，此时列表为`[1，4]`
3. 第三次取`[1, 2, 3]`中的第3个数据`3`当做实参传到匿名函数中，将`3*3`存储到列表中，此时列表为`[1，4，9]`



#### 案例2（多个参数的情况）

```python
# 函数需要两个参数
map(lambda x, y: x+y, [1, 2, 3], [4, 5, 6])
# 结果为:[5, 7, 9]

```

每次从列表`[1, 2, 3]`、`[4, 5, 6]`中各提取一个数值，然后当做实参传递到匿名函数中，将这个函数的返回值存储到列表中，

1. 第一次取`[1, 2, 3]`中的第1个数据`1`，取`[4, 5, 6]`中的第1个数据`4`, 当做实参传到匿名函数中，将`1+4`存储到列表中，此时列表为`[5]`
2. 第二次取`[1, 2, 3]`中的第2个数据`2`，取`[4, 5, 6]`中的第2个数据`5`, 当做实参传到匿名函数中，将`2+5`存储到列表中，此时列表为`[5, 7]`
3. 第三次取`[1, 2, 3]`中的第3个数据`3`，取`[4, 5, 6]`中的第3个数据`6`, 当做实参传到匿名函数中，将`3+6`存储到列表中，此时列表为`[5, 7, 9]`

#### 案例3（`def`函数的使用）

```python
def f1( x, y ):  
    return (x,y)

l1 = [ 0, 1, 2, 3, 4, 5, 6 ]  
l2 = [ 'Sun', 'M', 'T', 'W', 'T', 'F', 'S' ]
l3 = map( f1, l1, l2 ) 
print(list(l3))
# 结果为:[(0, 'Sun'), (1, 'M'), (2, 'T'), (3, 'W'), (4, 'T'), (5, 'F'), (6, 'S')]
```

上述案例，与之前的2个案例，很类似，仅仅是将函数由之前使用的匿名函数改为了`def`定义的函数而已，其他运行过冲没有差异

### 2.3 `filter函数`

`filter函数`会对`指定序列`执行`过滤`操作

```python
filter(...)
    filter(function or None, sequence) -> list, tuple, or string

    Return those items of sequence for which function(item) is true.  If
    function is None, return the items that are true.  If sequence is a tuple
    or string, return the same type, else return a list.
```

说明：

- function:接受一个参数，返回布尔值`True`或`False`
- sequence:序列可以是`str`，`tuple`，`list`等

`filter函数`会对序列参数`sequence`中的每个元素调用`function函数`，执行`function函数`在每次执行时，结果为`True`的序列元素存储到结果中

返回值的类型和参数sequence的类型相同

```python
filter(lambda x: x%2, [1, 2, 3, 4])
# [1, 3]

filter(None, "she")
# 'she'
```

### 2.4 `reduce函数`

`reduce函数`会对`参数序列`中元素进行重复操作

```python
reduce(...)
    reduce(function, sequence[, initial]) -> value

    Apply a function of two arguments cumulatively to the items of a sequence,
    from left to right, so as to reduce the sequence to a single value.
    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
    of the sequence in the calculation, and serves as a default when the
    sequence is empty.
```

说明：

- function:该函数有两个参数
- sequence:序列可以是`str`、`tuple`、`list`等
- initial:固定初始值

`reduce函数`依次从`sequence`中取一个元素，和`上一次调用function的结果`做参数`再次调用function`。

 第一次调用`function`时，如果提供`initial`参数，会以`sequence`中的第一个元素和`initial `作为参数调用`function`，否则会以序列`sequence`中的前两个元素做参数调用`function`

注意`function`参数不能为`None`

```python
reduce(lambda x, y: x+y, [1,2,3,4])
10

reduce(lambda x, y: x+y, [1,2,3,4], 5)
15

reduce(lambda x, y: x+y, ['aa', 'bb', 'cc'], 'dd')
'ddaabbcc'
```

#### 注意：

在`Python3`里, `reduce函数`已经被放置在`fucntools`模块里用的话要先引入： `from functools import reduce`



## 3. 作业练习

##### 1.使用map完成，计算1到9所有的数字的平方，并且把每个数字转为字符串

```python
m = map(str, map(lambda x: x ** 2, range(1, 10)))
```

#####  2.使用reduce完成,把列表里的数字变换成整数，比如[1, 3, 5, 7, 9]变成13579

```python
def fn(x, y):
    return x * 10 + y
print(reduce(fn, [1, 3, 5, 7, 9]))

```

##### 3.去除列表中带4的手机号

['18303517744', '15020030417', '15088931331', '15906878938', '13646514938', '13706636314',
          '18867793298', '13739742666', '15731102345', '13859652222', '18232102678', '13601261337',
          '15231099666', '18337728521', '15203802168', '18331758666', '18736599499', '13930109099',
          '15738888289', '15738888538', '15738888576', '15738888697', '15738888963', '13797904444',
          '15243191111', '18405311888', '18405312888', '13791080000', '13791090000',
          '13908376207', '13908335110',
          ]

```python
phones = ['18303517744', '15020030417', '15088931331', '15906878938', '13646514938', '13706636314',
          '18867793298', '13739742666', '15731102345', '13859652222', '18232102678', '13601261337',
          '15231099666', '18337728521', '15203802168', '18331758666', '18736599499', '13930109099',
          '15738888289', '15738888538', '15738888576', '15738888697', '15738888963', '13797904444',
          '15243191111', '18405311888', '18405312888', '13791080000', '13791090000',
          '13908376207', '13908335110',
          ]

r = filter(lambda x: x.find('4') == -1, phones)
print(list(r))

```

