# 描述符（Descriptor）

## 1. 目的

描述符其实我们之前已经见过了。

哪里见过了呢？先看一个例子

```python
class Foo:
    @property
    def attr(self):
        print('获取属性attr的值')
        return 'attr的值'

    def bar(self): pass

foo = Foo()
print(foo.attr)

```

运行效果：

![image-20190311050635757](./assets/image-20190311050635757.png)

上面这个例子中， `attr` 是类 `Foo` 的一个实例方法，可通过语句 `foo.attr()` 被调用。 但当它被 `@property` 装饰后，这个方法变成一个`property`属性。 `bar` 是一个未被装饰的实例方法。 我们查看一下类型`type(Foo.attr)` 与 `type(Foo.bar)` 的结果分别为：

```
<class 'property'>
<class 'function'>
```

发现`Foo.attr`的类型变成了`property`，其实`@property`的作用， 相当于是

```python
attr = property(attr)
```

大家看到，`attr`被装饰后，其实是指向了一个`property`类的实例化对象，

那我们执行`foo.attr` 为什么最后会执行attr方法呢？原理是什么呢？

其实`property`类就是一个`描述符`，下面我们学完描述符后，大家就明白`property`属性的原理了

## 2. 描述符

### 2.1 什么是`描述符`

官方定义：

```
In general, a descriptor is an object attribute with “binding behavior”, 
one whose attribute access has been overridden by methods in the descriptor protocol. 
Those methods are __get__(), __set__(), and __delete__(). 
If any of those methods are defined for an object, it is said to be a descriptor.
通常，描述符是具有“绑定行为”的对象属性，其属性访问已被描述符协议中的方法覆盖。
这些方法是__get__()，__set__()和 __delete__()。如果为对象定义了任何这些方法，则称其为描述符。
```

晕了没？我们还是简单描述吧：

如果一个类实现了`__get__()`、`__set__()`和`__delete__()`中的其中任意一种方法的`新式类`，用这个类创建的实例对象称之为“描述符”对象

用上述类创建的对象，用来当做另外一个类的类属性的值，我们把这个类属性称之为 “描述符”

```python
class MyDescriptor:
    def __get__(self, instance, owner):
        print('get called')
        return 'get'

    def __set__(self, instance, value):
        print('set called')

    def __delete__(self, instance):
        print('delete called')


class Foo:
    attr = MyDescriptor()

```

运行效果：

![image-20190311051234026](./assets/image-20190311051234026.png)

上面代码中`Foo`的属性`attr`是类`MyDescriptor`的实例化对象，`MyDescriptor`实现了`__get__()`、`__set__()`和`__delete__()`，那么`attr`就是成为了`描述符`，注意`attr`必须用`类属性`形式写

### 2.2 描述符作用

在上述代码下面添加如下代码：

```python
foo = Foo()
foo.attr
foo.attr = 'python'
del foo.attr
```

运行效果：

![image-20190311051403452](./assets/image-20190311051403452.png)

#### 说明：

- 当访问 `foo` 的 `attr` 属性时， `MyDescriptor` 的 `__get__` 方法被调用
- 当为 `attr` 设置一个新值时， `MyDescriptor` 的 `__set__` 方法被调用
- 当为删除属性 `attr` 时， `MyDescriptor` 的 `__delete__` 方法被调用

发现描述符的作用好像与我们之前学习的property功能有点相似。访问属性最终执行的是函数

#### 描述符作用：

当访问一个属性时，我们可以不直接给一个值，而是接一个描述器，让访问和修改设置时自动调用`__get__`方法和`__set__`方法。再在`__get__`方法和`__set__`方法中进行某种处理，就可以实现更改操作属性行为的目的。这就是描述器做的事情。

### 2.3 案例

定义一个类叫`Person`，有一个属性`name`，可以获取，赋值，要求赋值的时候，必须是字符串，否则报异常

```python
class NameDes(object):
    """可以实现描述符的类"""
    def __init__(self):
        self.__name = None

    def __get__(self, instance, owner):
        return self.__name

    def __set__(self, instance, value):
        if isinstance(value, str):
            self.__name = value
        else:
            raise TypeError("必须是字符串")
    def __delete__(self, instance):
        del self.__name


class Person(object):
    # 描述符
    name = NameDes()
```

#### 执行1

创建`Person`对象，给`name`属性赋值为字符串类型数据：

```python
p = Person()
p.name = "小李子"
print(p.name)
```

结果：

![image-20190311052051213](./assets/image-20190311052051213.png)



#### 执行2

创建`Person`对象，给`name`属性赋值为非字符串类型数据：

```python
p = Person()
p.name = 100
print(p.name)

```

![image-20190311052118499](./assets/image-20190311052118499.png)



## 3. 为什么要用描述符

### 3.1因为可以做类型检查

因为`Python`是一个动态类型解释性语言，不像`C/C++`等静态编译型语言，数据类型在编译时便可以进行验证，而`Python`中必须添加额外的类型检查逻辑代码才能做到这一点，这就是描述符的初衷。比如，有一个测试类`Test`，其具有一个类属性`name`

```python
class Test(object):
	name = None
```

正常情况下，`name`的值(其实应该是对象, `name`是引用)都应该是字符串，但是因为`Python`是动态类型语言，即使执行`Test.name = 3`，解释器也不会有任何异常。当然可以想到解决办法，就是提供一个`getter`，`setter`方法来统一读写`name`，读写前添加安全验证逻辑。

代码如下：

```python
class Test(object):
    name = None

    @classmethod
    def get_name(cls):
        return cls.name

    @classmethod
    def set_name(cls, val):
        if isinstance(val, str):
            cls.name = val
        else:
            raise TypeError("Must be an string")

```

虽然以上代码勉强可以实现对属性赋值的类型检查，但是会导致类型定义的臃肿和逻辑的混乱。

从`OOP`(面向对象编程)思想来看，只有属性自己最清楚自己的类型，而不是它所在的类，因此如果能将类型检查的逻辑根植于属性内部，那么就可以完美的解决这个问题，而描述符就是这样的利器。

为`name`属性定义一个(数据)描述符类，其实现了`__get__`和`__set__`方法，代码如下：

```python
class NameDes(object):
    def __init__(self):
        self.__name = None
    def  __get__(self, instance, owner):
        print('call __get__')
        return self.__name
    def  __set__(self, instance, value):
        print('call __set__')
        if  isinstance(value,str):
            self.__name = value
        else:
            raise TypeError("Must be an string")
```

测试类如下：

```python
class Test(object):
    name = NameDes()
```



测试代码及输出结果如下：

![image-20190311053206728](./assets/image-20190311053206728.png)



从打印的输出信息可以看到，当使用实例访问`name`属性(即执行`t.name`)时，便会调用描述符的`__get__`方法(注意`__get__`中添加的打印语句)。当使用实例对`name`属性进行赋值操作时(即`t.name = '小小明明'`)，从打印出的`call set`可以看到描述符的`__set__`方法被调用

至此，可以发现描述符的作用和优势，以弥补Python动态类型的缺点

### 3.2 比`property`属性更方便

#### 3.2.1 `property`——把函数调用伪装成对属性的访问

想象一下你正在编写管理电影信息的代码

最后写好的`Movie`类可能看上去是这样的：

```python
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        self.rating = rating  # 电影评分
        self.budget = budget  # 预算
        self.gross = gross  # 总利润
 
    def profit(self):
        """计算利润"""
        return self.gross - self.budget
```

你开始在项目的其他地方使用这个类，但是之后你意识到：如果不小心给电影打了负分怎么办？你觉得这是错误的行为，希望`Movie`类可以阻止这个错误。 

你首先想到的办法是将`Movie`类修改为这样：

```python
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        if rating < 0:
            raise ValueError("分数设置有误: %s" % rating)
        self.rating = rating  # 电影评分
        self.budget = budget  # 预算
        self.gross = gross  # 总利润
 
    def profit(self):
        """计算利润"""
        return self.gross - self.budget

```

但这行不通。

因为其他部分的代码都是直接通过`Movie的实例对象.rating`来赋值的——这个新修改的类只会在`__init__`方法中捕获错误的数据，但对于已经存在的类实例就无能为力了

如果有人试着运行`Movie的实例对象.rating=-100`，那么谁也没法阻止

作为一个Python程序员同时也是电影迷，你该怎么办？

幸运的是`property`可以解决这个问题，代码如下:

```python
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        self.__rating = rating  # 电影评分
        self.budget = budget  # 预算
        self.gross = gross  # 总利润

    @property
    def rating(self):
        return self.__rating

    @rating.setter
    def rating(self, value):
        if value < 0:
            raise ValueError("分数设置有误: %s" % value)
        self.__rating = value

    def profit(self):
        return self.gross - self.budget


m = Movie('三傻大闹宝莱坞', 97, 964000, 1300000)
print("电影评分：", m.rating)
try:
    m.rating = -100
except ValueError as ret:
    print(ret)

```

运行效果：

![image-20190311060520880](./assets/image-20190311060520880.png)

通过`property`属性，能够实现对评分的`rating`属性的特殊操作，最终实现对属性的操作变为了调用方法，从而完成一些更复杂的工作。

花点时间来欣赏一下Python这么做是多么的优雅：

如果没有`property`，我们将不得不把所有的实例属性隐藏起来，提供大量显式的类似`get_rating`和`set_ratingt`方法。像这样编写类的话，使用起来就会不断的去调用这些`getter/setter`方法，看起来就很臃肿。更糟的是，我们需要点名中的所有`Movie的实例对象.rating=xxx`这样的代码替换为`Movie的实例对象.set_rating(value)`。太蛋疼了！！

因此，`property`让我们将自定义的代码同变量的访问/设定联系在了一起，同时为你的类保持一个简单的访问属性的接口

#### 3.2.2 `property`的不足

对`property`来说，最大的缺点就是它们不能重复使用。

举个例子，假设你想为`budget`和`gross`这些字段也添加非负检查。

下面是修改过的新类：

```python
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        self.__rating = rating  # 电影评分
        self.__budget = budget  # 预算
        self.__gross = gross  # 总利润

    @property
    def rating(self):
        return self.__rating

    @rating.setter
    def rating(self, value):
        if value < 0:
            raise ValueError("分数设置有误: %s" % value)
        self.__rating = value

    def profit(self):
        return self.gross - self.budget

    @property
    def budget(self):
        return self.__budget

    @budget.setter
    def budget(self, value):
        if value < 0:
            raise ValueError("预算设置有误: %s" % value)
        self.__budget = value

    @property
    def gross(self):
        return self.__gross

    @gross.setter
    def gross(self, value):
        if value < 0:
            raise ValueError("总利润设置有误: %s" % value)
        self.__gross = value



m = Movie('三傻大闹宝莱坞', 97, 964000, 1300000)
print("电影评分：", m.rating)
try:
    m.rating = -100
except ValueError as ret:
    print(ret)

```

![image-20190311061301775](./assets/image-20190311061301775.png)

可以看到代码增加了不少，但重复的逻辑也出现了不少。虽然`property`可以让类从外部看起来接口整洁漂亮，但是却做不到内部同样整洁漂亮。



## 描述符登场（最终的大杀器）

这就是描述符所解决的问题

描述符是`property`的升级版，允许你为重复的`property`逻辑编写单独的类来处理

下面的示例展示了描述符是如何工作的：

```python
class NonNegative(object):
    """一个可以屏蔽负数的描述符"""
    def __init__(self, default):
        self.default = default
        self.data = dict()

    def __get__(self, instance, owner):
        # 当调用描述符时 即：x.d
        # instance 就是调用的那个实例对象 x，如果是类对象则为None
        # owner 就是 type(x)
        return self.data.get(instance, self.default)

    def __set__(self, instance, value):
        # 当调用描述符时 即：x.d = val
        # instance 就是调用的那个实例对象 x
        # owner 就是 type(x)
        if value < 0:
            raise ValueError("设置有误: %s（请使用非负数）" % value)
        self.data[instance] = value
class Movie(object):
    # 定义描述符
    rating = NonNegative(0)
    budget = NonNegative(0)
    gross = NonNegative(0)

    def __init__(self, title, rating, budget, gross):
        self.title = title
        self.rating = rating
        self.budget = budget
        self.gross = gross

    def profit(self):
        return self.gross - self.budget
m = Movie('三傻大闹宝莱坞', 97, 964000, 1300000)
print("电影评分：", m.rating)
try:
    m.rating = -100
except ValueError as ret:
    print(ret)

print("电影预算：", m.budget)
try:
    m.budget = -4567
except ValueError as ret:
    print(ret)

```

运行效果:

![image-20190311062009252](./assets/image-20190311062009252.png)

`Movie`类现在看起来非常清晰。我们在类的层面上创建了3个描述符，把它们当做普通的实例属性。显然，描述符在这里为我们做非负检查。



为了理解实例对象、类对象、以及描述符对象之间的关系，请看如下图示

![image-20190311062426867](./assets/image-20190311062426867.png)

