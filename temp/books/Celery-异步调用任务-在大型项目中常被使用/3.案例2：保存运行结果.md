# 案例2：保存运行结果

## 1. 介绍

如果想要保持追踪任务的状态，Celery需要在某个地方存储或发送这些状态

常见2种方式：

- `RabbitMQ`存储结果

```python
app = Celery('tasks', backend='amqp://xxxxx', broker='amqp://xxxxx')
```

- `Redis`存储结果

如果想把Redis作为结果后端，但仍使用RabbitMQ作为消息中间人(常见搭配)

```python
app = Celery('tasks', backend='redis://localhost', broker='amqp://xxxxxx')
```

## 2. 使用RabbitMQ存储运行结果

### 测试代码

`main.py`内容如下：

```python
from task2 import add

ret = add.delay(4, 4)
print(ret)

print(ret.get(timeout=1))  # 使用delay返回的结果对象.get()方法 获取结果
```

`task2.py`内容如下：

```python
from celery import Celery

app = Celery(
    'task',  # 当前模块的名字
    broker='amqp://guest@localhost//',  # 消息队列的url
    backend='amqp://guest@localhost//',  # 将调用的结果存储到MQ中
    # backend='redis://localhost:6379/8'  # 将调用的结果存储到Redis中
)


@app.task
def add(x, y):
    return x + y
```

### 重启Celery服务器

![image-20191129103957006](assets/image-20191129103957006.png)

### 运行结果

Celery服务器端打印的log信息如下：

![image-20191129104231559](assets/image-20191129104231559.png)

客户端调用任务的结果如下：

![image-20191129104301959](assets/image-20191129104301959.png)

## 3. 使用Redis存储运行结果

### 测试代码

使用Redis作为`backend`，存储执行结果，修改上述的`task2.py`代码，如下

![image-20191129104757953](assets/image-20191129104757953.png)

### 效果

重启Celery服务器后，可以再次执行`main.py`，此时会在Redis中看到刚刚执行的结果

![image-20191129104719276](assets/image-20191129104719276.png)

## 4. 总结

一般来说，我们在项目中将

- `broker`设置为RabbitMQ
- `backend`设置为Redis

这样我们的Web项目可以很快、便捷的从Redis获取需要的数据