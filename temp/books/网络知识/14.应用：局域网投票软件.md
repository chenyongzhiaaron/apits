# 应用：局域网投票软件

## 1. UDP服务器

> 用来接收投票信息

```python
import socket

# 创建UDP套接字
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 设置UDP套接字允许其广播(注意如果udp套接字需要广播，则一定要添加此语句，否则不用添加)
s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

dest_info = ("<broadcast>", 7899)  # <broadcast>会自动改为本语句网的广播ip

try:
    while True:
        # 1. 获取此次要投票的信息、
        info = input("请输入此次投票的信息描述，例如：第1组\n")

        # 2. 获取是否要发送
        send_flag = input("是否要发送给全部投票端(y or n)\n")

        if send_flag.lower() == "y":
            # 向本局域网中发送广播数据
            # 此时只要是本局域网中的电脑上有 用7899端口的udp程序 它就会收到此数据
            s.sendto(info.encode('utf-8'), dest_info)

            # 循环等待用户发送分数，直到按下ctrl+c结束本次评分
            try:
                # 有效分数
                scores_valid = list()
                # 无效分数
                scores_invalid = list()
                while True:
                    content, client_info = s.recvfrom(1024)
                    # print("接收到来自%s(%d)的投票：%s" % (client_info[0], client_info[1], content))
                    content = content.decode("gbk")
                    if content.isdigit():
                        scores_valid.append(int(content))  # 添加到列表中
                    else:
                        scores_invalid.append(content)
            except KeyboardInterrupt:
                pass
            finally:
                print(scores_valid)
                print(scores_invalid)
                score = sum(scores_valid) / len(scores_valid)
                print("刚刚投票的结果是:%.2f" % score)

except KeyboardInterrupt:
    pass
finally:
    # 通过try来保证，程序结束时，执行到close，即释放网络资源
    s.close()
```

## 2. UDP客户端（使用网络调试助手）

> 使用网络调试助手即可

## 3. 待升级功能

> 1. 防止一个用户在短时间内多次投票
> 2. 所有结果统计完成之后，显示最终结果，并且存到文件中

