# 订阅模型-Topic

## 1. 说明

`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符！

应用场景如下：

- 由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务
- 涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）
- 云端的不同种类服务的协调

```
Routingkey` 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert
```

通配符规则：

 `#`：匹配一个或多个词

 `*`：匹配不多不少恰好1个词

举例：

 `audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs`

 `audit.*`：只能匹配`audit.irs`

图示：

![1527088518574](assets/1527088518574.png)

解释：

- 红色Queue：绑定的是`usa.#` ，因此凡是以 `usa.`开头的`routing key` 都会被匹配到
- 黄色Queue：绑定的是`#.news` ，因此凡是以 `.news`结尾的 `routing key` 都会被匹配

## 2. demo

## 生产者

使用topic类型的Exchange，发送消息的routing key有3种： `item.isnert`、`item.update`、`item.delete`：

```python
import pika

# 建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机，设置类型为topic
channel.exchange_declare(exchange='messages2', exchange_type='topic')

# 定义路由键
routings = ['python.work', 'python.life', 'php.game', 'go.game', 'java.work', 'java.life', 'c.work']

# 将消息依次发送到交换机，并设定路由键
for routing in routings:
    message = '---------%s message-------' % routing
    channel.basic_publish(exchange='messages2', routing_key=routing, body=message)
    print("已经发送", message)

connection.close()
```

### 消费者1

```python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机，设置类型为topic
channel.exchange_declare(exchange='messages2', exchange_type='topic')

# 定义列表，用来存储这个队列绑定的Routingkey
routings = ['python.#', '#.work']

# 生成临时队列，并绑定到交换机上，设置路由键
result = channel.queue_declare(queue='', exclusive=True)
queue_name = result.method.queue
for routing in routings:
    channel.queue_bind(exchange='messages2', queue=queue_name, routing_key=routing)


def callback(ch, method, properties, body):
    print("消费者1：{}".format(body))


# rabbitmq使用callback来接收信息
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)

print('Waiting for messages2. To exit press CTRL+C')

channel.start_consuming()
```

### 消费者2

```python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机，设置类型为topic
channel.exchange_declare(exchange='messages2', exchange_type='topic')

# 定义列表，用来存储这个队列绑定的Routingkey
routings = ['#.life', '#.game']

# 生成临时队列，并绑定到交换机上，设置路由键
result = channel.queue_declare(queue='', exclusive=True)
queue_name = result.method.queue
for routing in routings:
    channel.queue_bind(exchange='messages2', queue=queue_name, routing_key=routing)


def callback(ch, method, properties, body):
    print("消费者2：{}".format(body))


# rabbitmq使用callback来接收信息
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)

print('Waiting for messages2. To exit press CTRL+C')

channel.start_consuming()
```

### 运行&测试

生产者

![image-20191128092816349](assets/image-20191128092816349.png)

消费者1

![image-20191128092853473](assets/image-20191128092853473.png)

消费者2

![image-20191128092911522](assets/image-20191128092911522.png)

## 3. 总结

Topic模式可以使用通配符做到灵活的消息传递方式