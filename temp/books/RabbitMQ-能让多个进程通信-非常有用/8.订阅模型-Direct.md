# 订阅模型-Direct

## 1. 说明

在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到`Direct`类型的交换机

在Direct模型下：

- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个`RoutingKey`（路由key）
- 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 `RoutingKey`。
- Exchange不再把消息交给每一个绑定的队列，而是根据消息的`Routing Key`进行判断，只有队列的`Routingkey`与消息的 `Routing key`完全一致，才会接收到消息

流程图：

![1527087677192](assets/1527087677192.png)

图解：

- P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。
- X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列
- C1：消费者，其所在队列指定了需要routing key 为 error 的消息
- C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息

**路由键的工作原理:**每个接收端的消息队列在绑定交换机的时候，可设定相应的路由键。发送端通过交换机发送消息时，可以指明路由键，交换机会根据路由键把消息发送到相应的消息队列，这样接收端就能够接收到消息了。

## 2. demo

将`info`、`warning`、`error`三种级别的信息发送到不同的接收端

### 生产者

此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete

```python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机，设置类型为direct,表示要根据设定的路由键来发送消息
channel.exchange_declare(exchange='messages1', exchange_type='direct')

# 定义三个路由键
routings = ['info', 'warning', 'error']

# 将消息依次发送到交换机，并设置路由键
for routing in routings:
    message = '-------%s message-----' % routing
    channel.basic_publish(exchange='messages1', routing_key=routing, body=message)
    print("已经发送：", message)

connection.close()
```

### 消费者1

我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。

```python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机，设置类型为direct
channel.exchange_declare(exchange='messages1', exchange_type='direct')

# 定义列表，用来存储这个队列绑定的Routing key
routings = ['info', 'error', 'warning']

# 生成临时队列，并绑定到交换机上，设置路由键
result = channel.queue_declare(queue='', exclusive=True)
queue_name = result.method.queue
for routing in routings:
    channel.queue_bind(exchange='messages1', queue=queue_name, routing_key=routing)


def callback(ch, method, properties, body):
    print("消费者1：{}".format(body))


# rabbitmq使用callback来接收信息
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)

print('Waiting for messages1. To exit press CTRL+C')

channel.start_consuming()
```

### 消费者2

我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。

```python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机，设置类型为direct
channel.exchange_declare(exchange='messages1', exchange_type='direct')

# 定义列表，用来存储这个队列绑定的Routing key
routings = ['info']

# 生成临时队列，并绑定到交换机上，设置路由键
result = channel.queue_declare(queue='', exclusive=True)
queue_name = result.method.queue
for routing in routings:
    channel.queue_bind(exchange='messages1', queue=queue_name, routing_key=routing)


def callback(ch, method, properties, body):
    print("消费者2：{}".format(body))


# rabbitmq使用callback来接收信息
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)

print('Waiting for messages1. To exit press CTRL+C')

channel.start_consuming()
```

### 运行&测试

生产者

![image-20191128091051204](assets/image-20191128091051204.png)

消费者1

![image-20191128091136374](assets/image-20191128091136374.png)

消费者2

![image-20191128091151996](assets/image-20191128091151996.png)

## 3. 总结

发送方通过`RoutingKey`指明发送到哪里，接收方也规定好接收的`RoutingKey`这样就可以做到给不同的消费者发送消息