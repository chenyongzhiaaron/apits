# 订阅模型-Fanout

Fanout，也称为广播。

## 1. 说明

![1527086564505](assets/1527086564505.png)

在广播模式下，消息发送流程是这样的：

1） 可以有多个消费者

2） 每个**消费者有自己的queue**（队列）

3） 每个**队列都要绑定到Exchange**（交换机）

4） **生产者发送的消息，只能发送到交换机**，交换机来决定要发给哪个队列，生产者无法决定

5） 交换机把消息发送给绑定过的所有队列

6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费

#### 生产者

两个变化：

1. 声明Exchange，不再声明Queue
2. 发送消息到Exchange，不再发送到Queue

## 2. demo

### 生产者

```python
import pika

# 建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机，exchange_type='fanout'表示广播的意思
channel.exchange_declare(exchange='messages', exchange_type='fanout')

# 将消息发送到交换机
# basic_publish方法的参数exchange被设定为相应交换机，因为是要广播出去，发送到所有队列，routing_key不需要设定
channel.basic_publish(exchange='messages', routing_key='', body='Hello World!')

print("已经发送'Hello World!'")

connection.close()
```

`basic_publish`方法的参数说明

- 参数：`exchange`如果为空，表示使用匿名的交换机。
- 参数：`routing_key`在使用匿名函数时需要指定，表示发送到那个队列的意思。

### 消费者1

```python
import pika

# 建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机 随机生成一个临时队列，并绑定到交换机上
# pika版本不同，exchange_declare方法传递的参数不同，type/exchange_type
channel.exchange_declare(exchange='messages', exchange_type='fanout')

# 随机生成队列，并绑定到交换机上,exclusive=True表示当接收端退出时，销毁临时产生的队列，不会占用资源
result = channel.queue_declare(queue="", exclusive=True)
queue_name = result.method.queue
channel.queue_bind(exchange='messages', queue=queue_name)


def callback(ch, method, properties, body):
    print("消费者1：{}".format(body))


# rabbitmq使用callback来接收信息
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)

print('Waiting for messages. To exit press CTRL+C')

channel.start_consuming()
```

要注意代码中：**队列需要和交换机绑定**

### 消费者2

```python
import pika

# 建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 定义交换机 随机生成一个临时队列，并绑定到交换机上
# pika版本不同，exchange_declare方法传递的参数不同，type/exchange_type
channel.exchange_declare(exchange='messages', exchange_type='fanout')

# 随机生成队列，并绑定到交换机上,exclusive=True表示当接收端退出时，销毁临时产生的队列，不会占用资源
result = channel.queue_declare(queue="", exclusive=True)
queue_name = result.method.queue
channel.queue_bind(exchange='messages', queue=queue_name)


def callback(ch, method, properties, body):
    print("消费者2：{}".format(body))


# rabbitmq使用callback来接收信息
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)

print('Waiting for messages. To exit press CTRL+C')

channel.start_consuming()
```

### 运行&测试

生产者 ![image-20191128084309718](assets/image-20191128084309718.png)

消费者1

![image-20191128084420105](assets/image-20191128084420105.png)

消费者2

![image-20191128084435468](assets/image-20191128084435468.png)

图形化界面看到的变化

![image-20191128084637556](assets/image-20191128084637556.png)

![image-20191128084701406](assets/image-20191128084701406.png)

当将2个消费者关闭之后的变化

![image-20191128085159537](assets/image-20191128085159537.png)

## 3. 总结

因为交换机Fanout模式时投递的消息被拷贝到所有绑定到它的队列，所以这种方式的案例都极其相似：

- 大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件
- 体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端
- 分发系统使用它来广播各种状态和配置更新
- 在群聊的时候，它被用来分发消息给参与群聊的用户