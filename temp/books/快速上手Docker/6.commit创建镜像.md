# 制作镜像方式1（了解）



## 一、引入

有时，我们在一个容器中安装了需要的软件或者进行了较为复杂的配置，此时能否把这个容器制作成一个镜像呢？

答案：可以

这样我们就可以将这个镜像进行分享，从而让其他的开发者也直接可以使用



## 二、准备一个较为满意的容器

查看镜像Ubuntu16.04

![image-20191124174439528](assets/image-20191124174439528.png)

创建容器

![image-20191124174653949](assets/image-20191124174653949.png)

修改更新源为国内的

注意，Ubuntu中决定更新源的文件是`/etc/apt/sources.list`，可以将其内容修改为如下：

```
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse
```

![image-20191124174805761](assets/image-20191124174805761.png)

复制更新源数据到容器

![image-20191124175002670](assets/image-20191124175002670.png)

更新`source.list`文件

![image-20191124175158347](assets/image-20191124175158347.png)

![image-20191124175245787](assets/image-20191124175245787.png)

安装软件Vim

![image-20191124175640080](assets/image-20191124175640080.png)

安装成功

![image-20191124175718846](assets/image-20191124175718846.png)

![image-20191124175656040](assets/image-20191124175656040.png)

## 三、使用commit制作镜像

我们可以直接使用 `docker commit` 指令将一个容器制作成一个镜像：

```
docker commit 容器名称 镜像名称:标签
```

![image-20191124180050421](assets/image-20191124180050421.png)

查看创建的镜像信息

![image-20191124181813961](assets/image-20191124181813961.png)

运行刚刚制作的镜像为容器： ![image-20191124180226859](assets/image-20191124180226859.png)

## 四、其它

### 扩展

![image-20191124182032580](assets/image-20191124182032580.png)

要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 `docker commit` 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。

### 慎用 `docker commit`

使用 `docker commit` 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。

首先，如果仔细观察之前的 `docker diff my_ubuntu:1.0` 的结果，你会发现除了真正想要修改的文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。

此外，使用 `docker commit` 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 **黑箱镜像**，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 `docker diff` 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。

一句话：不要使用`docker commit`制作镜像