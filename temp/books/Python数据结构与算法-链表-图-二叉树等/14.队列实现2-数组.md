# 队列的实现

用数组实现的队列叫作**顺序队列**，用链表实现的队列叫作**链式队列**。

## 数组实现的顺序队列

### 基本实现

队列需要两个指针：一个是 `head` 指针，指向队头；一个是 `tail` 指针，指向队尾。

当 `a、b、c、d` 依次入队之后，队列中的 `head` 指针指向`下标为 0` 的位置，`tail` 指针指向`下标为 4` 的位置。

![1570433366474](assets/1570433366474.png)

调用两次出队操作之后，队列中 `head` 指针指向下`标为 2` 的位置，`tail` 指针仍然指向`下标为 4` 的位置。

![1570433383574](assets/1570433383574.png)

随着不停地进行入队、出队操作，`head` 和 `tail` 都会持续往后移动。

```python
class ArrayQueue:
    """用数组实现的队列"""

    def __init__(self, capacity: int):
        self.items = [None] * capacity
        self.__capacity = capacity
        self.head = 0  # 队头下标
        self.tail = 0  # 队尾下标

    def enqueue(self, item):
        """入队"""
        if self.tail == self.__capacity:
            return False
        self.items[self.tail] = item
        self.tail += 1
        return True

    def dequeue(self):
        """出队"""
        if self.head == self.tail:
            return None
        item = self.items[self.head]
        self.head += 1
        return item

    def __str__(self) -> str:
        return str(self.items[self.head:self.tail])


if __name__ == "__main__":
    # 创建一个队列
    array_queue = ArrayQueue(3)
    # 入队
    array_queue.enqueue(11)
    array_queue.enqueue(22)
    array_queue.enqueue(33)
    # array_queue.enqueue(44)  # 入队失败，因为已经满了
    # 遍历
    print(array_queue)
    # 出队
    print("出队的数据：", array_queue.dequeue())
    # 遍历
    print(array_queue)
    # 入队
    array_queue.enqueue(44)
    # 遍历
    print(array_queue)

```

运行效果：

```
[11, 22]
出队的数据： 11
[22]
[22, 44]
```



### 优化升级

当 `tail` 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这时只需要触发一次数据的搬移操作即可。

当队列的 `tail` 指针移动到数组的最右边后，如果有新的数据入队，就将 `head` 到 `tail` 之间的数据，整体搬移到数组中 `0` 到 `tail-head` 的位置。

![1570433406655](assets/1570433406655.png)



将如下函数，替换上述代码中的`enqueue`函数

```python
    def enqueue(self, item):
        """入队"""
        # 表示队列末尾没有空间了
        if self.tail == self.__capacity:
            if self.head == 0:
                return False
            # 数据搬移
            for i in range(self.head, self.tail):
                self.items[i - self.head] = self.items[i]
            # 搬移完之后重新更新 head 和 tail
            self.tail -= self.head
            self.head = 0
        self.items[self.tail] = item
        self.tail += 1
        return True
```

整体代码如下：

```python
class ArrayQueue:
    """用数组实现的队列"""

    def __init__(self, capacity: int):
        self.items = [None] * capacity
        self.__capacity = capacity
        self.head = 0  # 队头下标
        self.tail = 0  # 队尾下标

    def enqueue(self, item):
        """入队"""
        # 表示队列末尾没有空间了
        if self.tail == self.__capacity:
            if self.head == 0:
                return False
            # 数据搬移
            for i in range(self.head, self.tail):
                self.items[i - self.head] = self.items[i]
            # 搬移完之后重新更新 head 和 tail
            self.tail -= self.head
            self.head = 0
        self.items[self.tail] = item
        self.tail += 1
        return True

    def dequeue(self):
        """出队"""
        if self.head == self.tail:
            return None
        item = self.items[self.head]
        self.head += 1
        return item

    def __str__(self) -> str:
        return str(self.items[self.head:self.tail])


if __name__ == "__main__":
    # 创建一个队列
    array_queue = ArrayQueue(3)
    # 入队
    array_queue.enqueue(11)
    array_queue.enqueue(22)
    array_queue.enqueue(33)
    # array_queue.enqueue(44)  # 入队失败，因为已经满了
    # 遍历
    print(array_queue)
    # 出队
    print("出队的数据：", array_queue.dequeue())
    # 遍历
    print(array_queue)
    # 入队
    array_queue.enqueue(44)
    # 遍历
    print(array_queue)

```

运行效果：

```
[11, 22, 33]
出队的数据： 11
[22, 33]
[22, 33, 44]
```

