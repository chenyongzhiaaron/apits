# 循环数组实现的队列

上一节用数组来实现队列的时候，在 `tail==n` 时，会有数据搬移操作，`采用循环数组则不需要数据搬移操作`。

原本数组是有头有尾的是一条直线，把它首尾相连扳成一个环：

![1570433438772](assets/1570433438772.png)

图中这个队列的大小为 `8`，当前 `head=4，tail=7`。

当有一个新的元素 `a` 入队时，放入下标为 `7` 的位置， `tail` 并不更新为 `8`，而是到下标为 `0` 的位置。

当再有一个元素 `b` 入队时，将 `b` 放入下标为 `0` 的位置，然后 `tail` 加 `1` 更新为 `1`。

在 `a，b` 依次入队之后，循环队列中的元素就变成了下面的样子：

![1570433457896](assets/1570433457896.png)

**确定队空和队满的判定条件**。

队列为空的判断条件是 `head == tail`。

![1570433479539](assets/1570433479539.png)

如上图，显然队列满的判断条件是`(tail+1)%n=head`，

为了避免和队空的判断条件混淆，则必须牺牲一个数组的存储空间。

python实现代码：

```python
from typing import Optional


class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity + 1
        self.items = [None] * self.capacity
        self.head = 0  # head表示队头下标
        self.tail = 0  # tail表示队尾下标

    def enqueue(self, item) -> bool:
        """入队"""
        if (self.tail + 1) % self.capacity == self.head:
            return False
        self.items[self.tail] = item
        self.tail = (self.tail + 1) % self.capacity

    def dequeue(self) -> Optional[str]:
        # 如果head == tail 表示队列为空
        if self.head == self.tail:
            return None
        item = self.items[self.head]
        self.head = (self.head + 1) % self.capacity
        return item

    def __str__(self) -> str:
        if self.tail >= self.head:
            return str(self.items[self.head: self.tail])
        else:
            return str(self.items[self.head:] + self.items[:self.tail])


if __name__ == "__main__":
    # 创建一个循环队列
    circular_queue = CircularQueue(4)
    # 入队
    circular_queue.enqueue(11)
    circular_queue.enqueue(22)
    circular_queue.enqueue(33)
    circular_queue.enqueue(44)
    # circular_queue.enqueue(55)  # 失败，因为队列已满
    # 遍历
    print(circular_queue)
    # 出队
    print("出队的数据：", circular_queue.dequeue())
    # 遍历
    print(circular_queue)
    # 入队
    circular_queue.enqueue(55)
    # 遍历
    print(circular_queue)

```

运行效果：

```
[11, 22, 33, 44]
出队的数据： 11
[22, 33, 44]
[22, 33, 44, 55]
```

