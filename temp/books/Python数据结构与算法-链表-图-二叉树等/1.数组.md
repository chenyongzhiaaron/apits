# 数组

**数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**

数组是一种最基础的数据结构，在大部分编程语言中，数组都是从 0 开始编号的。



## 数组实现随机访问的方法

数组使用了**连续的内存空间和相同类型的数据**。使得它可以“随机访问”，但同时也让数组的删除、插入等操作变得非常低效，为了保证连续性，就需要做大量的数据搬移工作。

**数组是如何实现根据下标随机访问数组呢？**

以一个长度为 10 的 int 类型的数组 `int a[10];`为例。

计算机会给每个内存单元分配一个地址，并通过地址来访问内存中的数据。

下图中，假设计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。

![](assets/6.jpg)

当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```c
a[i]_address = base_address + i * data_type_size
```

* data_type_size 表示数组中每个元素的大小。

上面的数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。



## 数组的低效操作

### 插入操作

假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，需要将第 k～n 这部分的元素都顺序地往后挪一位。

如果在数组的末尾插入元素，那就不需要移动数据了。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位。 

如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。

假设数组 a[10] 中存储了如下 5 个元素：a，b，c，d，e。

现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可：

![](assets/7.jpg)



如果数据是有序的，即 a, b, c, d, e 顺序不能改变，参考demo如下：

```c
#include<stdio.h>

void show_info(char * p, int length){
    for(int i=0; i<length;i++){
        printf("%d-->%c\n", i, p[i]);
    }
}

int insert(char *info_p, int length, int * size, int index, char temp){
    // 验证是否可以操作
    if(index < 0 || index >= length || *size>=length)  // 如果需要插入数据的位置
        return -1;  // 用返回 -1 标记为 失败

    // 数据末尾添加数据
    if(index >= *size){
        info_p[*size] = temp;  // 最后添加数据
        (*size) ++;  // 现有数据长度+1
        return 0;
    }

    // 中间部位插入数据
    // 先挪动数据
    int i=*size-1;
    for(;i>=index; i--){
        info_p[i+1]=info_p[i];
    }
    // 再插入数据
    info_p[i+1] = temp;
    (*size) ++;
    
    return 0;  // 用返回 0 表示 未出错，程序正常
}

int main(int argc, char* argv[]){
    // 定义一个字符数组
    char info[10] = {'a', 'b', 'c', 'd', 'e'};
    int info_size = 5;  // 表示的意思是记录 info数组当前已经存储的数据元素的个数

    // 插入新数据
    char insert_data = 'x';

    // 插入之前
    printf("插入之前.....\n");
    show_info(info, 10);  // 把需要打印的字符串数组的名字 以及 数组元素的格式 传递给函数
                          // 可以把10 写成其他的方式吗？是什么？sizeof(info) / sizeof(char)

    int ret = insert(info, 10, &info_size, 2, insert_data);
    printf("插入操作结果:%d\n", ret);

    // 插入之后
    printf("插入之后.....\n");
    show_info(info, 10);

    return 0;
}


```

执行结果：

```
插入之前.....
0-->a
1-->b
2-->c
3-->d
4-->e
5-->
6-->
7-->
8-->
9-->
插入操作结果:0
插入之后.....
0-->a
1-->b
2-->x
3-->c
4-->d
5-->e
6-->
7-->
8-->
9-->
```





### **删除操作**

如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。

如果删除数组末尾的数据，则最好；如果删除开头的数据，则最坏；

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。可以将多次删除操作集中在一起执行。

比如数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。要依次删除 a，b，c 三个元素：

![](assets/8.jpg)

为了避免 d，e，f，g，h 这几个数据会被搬移三次，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作。

这有点像是Python中的标记清除垃圾回收算法的核心思想。



## 警惕数组的访问越界问题

先分析一下这段 C 语言代码的运行结果：

```c
#include<stdio.h>

int main(int argc, char* argv[]){
    int i = 0;
    int arr[] = {11, 22, 33};

    for(; i<=3; i++){
        printf("i=%d, arr[%d]=%d\n", i, i, arr[i]);
    }
    return 0;
}

```

上段程序运行结果：

```
i=0, arr[0]=11
i=1, arr[1]=22
i=2, arr[2]=33
i=3, arr[3]=-1121713994
```

能否发现 `i=3, arr[3]=-1121713994`也执行了，但数组只有3个元素，而`arr[3]`实际上是第4个数据了

那这说明什么？

在 C 语言中，a[3] 被定位到某块不属于数组的内存地址上，其他高级语言一般会报下标越界异常。

访问数组的本质就是访问一段连续内存，在 C 语言中只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

` C语言把数组越界检查的工作丢给程序员来做`，但Python本身就会做越界检查，比如下面这几行Python代码，就会抛出异常

```python
nums = [11, 22, 33]
num2[3] = 44  # 此时产生异常
```



## 为什么数组要从 0 开始编号?

**为什么数组要从 0 开始编号，而不是从 1 开始呢？** 从 1 开始不是更符合人类的思维习惯吗？

从数组存储的内存模型上来看，**“下标”最确切的定义应该是“偏移（offset）”**。

从 0 开始编号，数组 a[k] 的内存寻址公式为：

```c
a[k]_address = base_address + k * type_size
```

从 1 开始编号，数组 a[k] 的内存寻址公式为：

```c
a[k]_address = base_address + (k-1)*type_size
```

对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。另外，C 语言设计者用 0 开始计数数组下标，之后的Python、 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习其他编程语言的学习成本，因此继续沿用了从 0 开始计数的习惯。



当然，并不是所有语言的数组都是从 0 开始计数的，比如 Matlab。



## 二维数组的内存寻址公式

对于 m * n 的数组，`a[i][j] (i<m,j<n)​`的地址为：

```c
address = base_address + (i*n+j)*type_size
```

