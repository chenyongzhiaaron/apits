# 多对多关联操作

## 1. 需求以及准备工作

{% em color="#fff700" %}一个管理员帐号(比如root),可以关联多台服务器,一个服务器也可以有多个管理员帐号{% endem %}

### 1.1. 需求:

三张表:

1. `主机表`:包括`nid` `hostname` `port` `ip`
2. `管理员表`:包括:`nid` `username`
3. `主机对应管理员表`: `nid` `主机id` `管理员id`



### 1.2. 创建数据表

注意为了与之前的练习区分，所以重新建立了一个数据库`py3_sqlalchemy_2019_2`请注意选择

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, Integer, ForeignKey
from sqlalchemy.orm import relationship


# 链接是需要指定要用到的MySQL数据库
engine = create_engine('mysql+pymysql://root:python@localhost:3306/py3_sqlalchemy_2019_2?charset=utf8')
Base = declarative_base()  # 生成SQLORM基类


class Host(Base):
    __tablename__ = 'host'
    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(32))
    port = Column(String(32))
    ip = Column(String(32))


class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(32))


# 多对多
class HostToUser(Base):
    __tablename__ = 'host_to_user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    host_id = Column(Integer, ForeignKey('host.id'))  # 外键
    user_id = Column(Integer, ForeignKey('user.id'))  # 外键
    # 多对多关系维护操作
    host = relationship('Host', backref='users')
    user = relationship('User', backref='hosts')


def init_db():
    """创建所有的数据表"""
    Base.metadata.create_all(engine)


def drop_db():
    """删除所有的数据表"""
    Base.metadata.drop_all(engine)


# 创建所有的数据库
init_db()
# 删除所有的数据表
# drop_db()
# exit()


```

![image-20190506204027455](assets/image-20190506204027455.png)

![image-20190506204056128](assets/image-20190506204056128.png)

![image-20190506204129022](assets/image-20190506204129022.png)

![image-20190506205422934](assets/image-20190506205422934.png)

![image-20190506205447848](assets/image-20190506205447848.png)





### 1.3. 添加数据

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, Integer, ForeignKey
from sqlalchemy.orm import relationship, sessionmaker

# 链接是需要指定要用到的MySQL数据库
engine = create_engine('mysql+pymysql://root:python@localhost:3306/py3_sqlalchemy_2019_2?charset=utf8')
Base = declarative_base()  # 生成SQLORM基类


class Host(Base):
    __tablename__ = 'host'
    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(32))
    port = Column(String(32))
    ip = Column(String(32))


class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(32))


# 多对多
class HostToUser(Base):
    __tablename__ = 'host_to_user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    host_id = Column(Integer, ForeignKey('host.id'))  # 外键
    user_id = Column(Integer, ForeignKey('user.id'))  # 外键
    # 多对多关系维护操作
    host = relationship('Host', backref='users')
    user = relationship('User', backref='hosts')


def init_db():
    """创建所有的数据表"""
    Base.metadata.create_all(engine)


def drop_db():
    """删除所有的数据表"""
    Base.metadata.drop_all(engine)


Session = sessionmaker(bind=engine)
session = Session()

# 多对多操作
# 创建Host对象并添加到数据表中
h1 = Host(hostname='c1', port='22', ip='192.1168.1.1')
h2 = Host(hostname='c2', port='22', ip='192.1168.1.2')
h3 = Host(hostname='c3', port='22', ip='192.1168.1.3')
h4 = Host(hostname='c4', port='22', ip='192.1168.1.4')
h5 = Host(hostname='c5', port='22', ip='192.1168.1.5')
session.add_all([h1, h2, h3, h4, h5])
session.commit()

# 创建User对象并添加到数据表中
u1 = User(username='root')
u2 = User(username='db')
u3 = User(username='nb')
u4 = User(username='sb')
session.add_all([u1, u2, u3, u4])
session.commit()

# 将关联数据添加到聚合表中
session.add_all([
    HostToUser(host=h1, user=u1),
    HostToUser(host=h1, user=u2),
    HostToUser(host=h1, user=u3),
    HostToUser(host=h2, user=u2),
    HostToUser(host=h2, user=u4),
    HostToUser(host=h2, user=u3),
])
session.commit()

session.close()

```

![image-20190506204628997](assets/image-20190506204628997.png)

![image-20190506204647614](assets/image-20190506204647614.png)

![image-20190506205614538](assets/image-20190506205614538.png)



## 2. 查询

### 无虚拟关系的原始方式

需求:查询主机C1的管理员帐号

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, Integer, ForeignKey
from sqlalchemy.orm import relationship, sessionmaker

# 链接是需要指定要用到的MySQL数据库
engine = create_engine('mysql+pymysql://root:python@localhost:3306/py3_sqlalchemy_2019_2?charset=utf8')
Base = declarative_base()  # 生成SQLORM基类


class Host(Base):
    __tablename__ = 'host'
    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(32))
    port = Column(String(32))
    ip = Column(String(32))


class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(32))


# 多对多
class HostToUser(Base):
    __tablename__ = 'host_to_user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    host_id = Column(Integer, ForeignKey('host.id'))  # 外键
    user_id = Column(Integer, ForeignKey('user.id'))  # 外键
    # 多对多关系维护操作
    host = relationship('Host', backref='users')
    user = relationship('User', backref='hosts')


def init_db():
    """创建所有的数据表"""
    Base.metadata.create_all(engine)


def drop_db():
    """删除所有的数据表"""
    Base.metadata.drop_all(engine)


Session = sessionmaker(bind=engine)
session = Session()

# 1.先在host表中查询c1的id
host_obj = session.query(Host).filter(Host.hostname == 'c1').one()
# print(host_obj)  # 查询出来的是一个Host对象 <__main__.Host object at 0x108034e10>
print(host_obj.hostname, host_obj.ip)

# 2.查询host_to_user表中的所有host_id等于c1的id的对应的host_user_id
host_to_user = session.query(HostToUser.user_id).filter(HostToUser.host_id == host_obj.id).all()
print(host_to_user)  # [(1,), (2,), (3,)]

ids = [x[0] for x in host_to_user]
print(ids)  # [1, 2, 3]

# 通过查到的host_user_id查询hostuser表中的对应的管理员用户名
users = session.query(User.username).filter(User.id.in_(ids)).all()
print(users)  # [('root',), ('db',), ('nb',)]

session.close()

```

结果:

![image-20190506210201046](assets/image-20190506210201046.png)

是不是很麻烦?

### 虚拟关系的查询

需求:同上,查询主机C1的管理员帐号

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, Integer, ForeignKey
from sqlalchemy.orm import relationship, sessionmaker

# 链接是需要指定要用到的MySQL数据库
engine = create_engine('mysql+pymysql://root:python@localhost:3306/py3_sqlalchemy_2019_2?charset=utf8')
Base = declarative_base()  # 生成SQLORM基类


class Host(Base):
    __tablename__ = 'host'
    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(32))
    port = Column(String(32))
    ip = Column(String(32))


class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(32))


# 多对多
class HostToUser(Base):
    __tablename__ = 'host_to_user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    host_id = Column(Integer, ForeignKey('host.id'))  # 外键
    user_id = Column(Integer, ForeignKey('user.id'))  # 外键
    # 多对多关系维护操作
    host = relationship('Host', backref='users')
    user = relationship('User', backref='hosts')


def init_db():
    """创建所有的数据表"""
    Base.metadata.create_all(engine)


def drop_db():
    """删除所有的数据表"""
    Base.metadata.drop_all(engine)


Session = sessionmaker(bind=engine)
session = Session()

# 1.反向查找,查询host表中c1的信息,会得到一个对象,对象中存在一个已经设置好的虚拟关系:users
host_obj = session.query(Host).filter(Host.hostname == 'c1').first()
print(host_obj)
print(host_obj.users)

# 2.正向查找,遍历对象属性
for item in host_obj.users:
    print("-" * 20)
    print(item)  # 是HostToHostUser对象
    print(item.user)  # <__main__.HostUser object at 0x102b18b38>
    print(item.user.username)  #


session.close()

```

结果:

![image-20180811121403398](assets/05-sqlalchemy/image-20180811121403398.png)

注意:**多对多的话,正反查询都是遍历对象中的属性**

### 同一需求最简单的方式

需求还是同上:查询主机C1的管理员帐号

需要在两张表的一张表中加一条`users=relationship('User',secondary=HostToUser.__table__,backref='hosts')`,我加到了host表中



```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, Integer, ForeignKey
from sqlalchemy.orm import relationship, sessionmaker

# 链接是需要指定要用到的MySQL数据库
engine = create_engine('mysql+pymysql://root:python@localhost:3306/py3_sqlalchemy_2019_2?charset=utf8')
Base = declarative_base()  # 生成SQLORM基类


# 多对多
class HostToUser(Base):
    __tablename__ = 'host_to_user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    host_id = Column(Integer, ForeignKey('host.id'))  # 外键
    user_id = Column(Integer, ForeignKey('user.id'))  # 外键
    # 多对多关系维护操作
    # host = relationship('Host', backref='users')
    # user = relationship('User', backref='hosts')
    

class Host(Base):
    __tablename__ = 'host'
    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(32))
    port = Column(String(32))
    ip = Column(String(32))
    users = relationship('User', secondary=HostToUser.__table__, backref='hosts')


class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(32))


def init_db():
    """创建所有的数据表"""
    Base.metadata.create_all(engine)


def drop_db():
    """删除所有的数据表"""
    Base.metadata.drop_all(engine)


Session = sessionmaker(bind=engine)
session = Session()

# 1.反向查找,查询host表中c1的信息,会得到一个对象,对象中存在一个已经设置好的虚拟关系:users
host_obj = session.query(Host).filter(Host.hostname == 'c1').first()
print(host_obj)
print(host_obj.hostname, host_obj.ip)

# 2.正向查找,遍历对象属性
for item in host_obj.users:
    print("-" * 20)
    print(item)
    print(item.username)

session.close()

```

![image-20190506211241872](assets/image-20190506211241872.png)

## 总结

为了实现多对多的关系，可以用2种方式来描述他们之间的关系

方式1：在中间表中用`relationship`进行关联，这种方式容易理解，但是在查询时不方便

![image-20190506211630642](assets/image-20190506211630642.png)

方式2：把`relationship`放到多对多中的2个表中任意一个中，让他们在模型上直接对应，注意仅仅是模型上对应而在数据库中的记录中依然是需要中间表的；这种方式实现更为简单，但是初见感觉有些不容易理解，多练习就克服了

![image-20190506211751922](assets/image-20190506211751922.png)

